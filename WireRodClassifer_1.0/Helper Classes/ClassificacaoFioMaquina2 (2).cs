//
// File generated by HDevelop for HALCON/.NET (C#) Version 13.0.2
//
//  This file is intended to be used with the HDevelopTemplate or
//  HDevelopTemplateWPF projects located under %HALCONEXAMPLES%\c#

using System;
using HalconDotNet;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Globalization;
using System.Diagnostics;
using WireRodClassifer_1._0.Helper_Classes;

//using math.h;
using WireRodClassifer_1._0;
using System.Windows;
using System.Threading;

public partial class HDevelopExport
{
    private CancellationToken token;
    public HTuple hv_ExpDefaultWinHandle;
    private string folderPath;

    public void HDevelopStop()
    {
        MessageBox.Show("Press button to continue", "Program stop");
    }

    Complex vetorBordaComplexo = new Complex(10,7);    // vetor de complexos com os dados da borda alocados nas respectivas partes reais
    //complex * vetorBordaComplexo2;

    // Main procedure 
    private void action(HTuple hv_acqHandle)
    {
        // Local iconic variables 

        HObject ho_Image, ho_RectangleEsq, ho_REsqXLD;
        HObject ho_RectangleDir, ho_RDirXLD, ho_ImageReducedEsq=null;
        HObject ho_GrayImageEsq=null, ho_ImageEmphasizeEsq=null;
        HObject ho_RegionEsq=null, ho_ContoursEsq=null, ho_FullLeftContour=null;
        HObject ho_ContornoEsq=null, ho_ContornoEsq2=null, ho_SmoothedContoursESQ=null;
        HObject ho_RegressContoursESQ=null, ho_Line=null, ho_ContoursAffineTrans=null;
        HObject ho_ImageReducedDir=null, ho_GrayImageDir=null, ho_ImageEmphasizeDir=null;
        HObject ho_RegionDir=null, ho_ContoursDir=null, ho_FullRightContour=null;
        HObject ho_ContornoDir=null, ho_SmoothedContoursDIR=null;
        HObject ho_RegressContoursDIR=null, ho_ContoursAffineTrans1=null;
        HObject ho_ContornoEsqAux = null;
        HObject ho_ContornoDirAux = null, ho_Roi_Dt = null, ho_Roi_Dt_Bb = null;
        HObject ho_Roi_Dt_Bb_Gs = null, ho_Roi_Dt_Bb_Gs_Emp = null;
        // ========================================================
        // -> Variáveis Icônicas Classificador Area/Número Buracos:
        HObject ho_ContornoEsqRed=null, ho_ContRegBurEsq=null, ho_DomRegBurEsq=null;
        HObject ho_RegBurEsq=null, ho_BurEsq=null, ho_BurEsqCon=null;
        HObject ho_ContornoDirRed=null, ho_BurDir=null, ho_BurDirCon=null;
        HObject ho_ContRegBurDir=null, ho_DomRegBurDir=null, ho_RegBurDir=null;
        // ========================================================
        
        // Local control variables 

        HTuple hv_arquivoSaida1 = null, hv_AcqHandle = null;
        HTuple hv_Revision = null, hv_Width = null, hv_Height = null;
        HTuple hv_MaxImageNum = null, hv_ImageNum = null, hv_RectEsq = null;
        HTuple hv_RectEsqXLD = null, hv_RectDir = null, hv_RectDirXLD = null;
        HTuple hv_Length = new HTuple(), hv_Nx = new HTuple();
        HTuple hv_Ny = new HTuple(), hv_Dist = new HTuple(), hv_Fpx = new HTuple();
        HTuple hv_Fpy = new HTuple(), hv_Lpx = new HTuple(), hv_Lpy = new HTuple();
        HTuple hv_Mean = new HTuple(), hv_Deviation = new HTuple();
        HTuple hv_PhiEsq = new HTuple(), hv_RotacaoEsq = new HTuple();
        HTuple hv_HomMat2DIdentity = new HTuple(), hv_HomMat2DRotate = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_index = new HTuple();
        HTuple hv_Length1 = new HTuple(), hv_Nx1 = new HTuple();
        HTuple hv_Ny1 = new HTuple(), hv_Dist1 = new HTuple();
        HTuple hv_Fpx1 = new HTuple(), hv_Fpy1 = new HTuple();
        HTuple hv_Lpx1 = new HTuple(), hv_Lpy1 = new HTuple();
        HTuple hv_Mean1 = new HTuple(), hv_Deviation1 = new HTuple();
        HTuple hv_PhiDir = new HTuple(), hv_RotacaoDir = new HTuple();
        HTuple hv_HomMat2DIdentity1 = new HTuple(), hv_HomMat2DRotate1 = new HTuple();
        HTuple hv_Row1 = new HTuple(), hv_Col1 = new HTuple();
        HTuple hv_comprimentosBordaEsquerda = new HTuple();
        HTuple hv_ContornoEsqMax = new HTuple();
        HTuple hv_indexMaiorContorno = new HTuple();
        HTuple hv_tamanhoVetorBordasEsquerda = new HTuple();
        HTuple hv_comprimentosBordaDireita = new HTuple(), hv_tamanhoVetorBordasDireita = new HTuple();
        HTuple hv_ContornoDirMax = new HTuple();
        HTuple hv_Pdi_Fm_On = null, hv_Hst_Abs_Vec = null, hv_Roi_Med = new HTuple();
        HTuple hv_Roi_Var = new HTuple(), hv_RectTopo = null, hv_nomeArquivoVideoSaida = new HTuple();
        HTuple hv_ImageNumString = new HTuple();
        int indexVetores;
        DateTime CurrentTime = DateTime.Now;
        string data;
        string horario;
        int aguardandoMaterial = 1; // 1 -> sistema está aguardando material no leito ; 0 -> há material no leito
        StreamWriter arquivoNotas;  // sintetiza o nome do próximo arquivo txt com as notas
        StreamWriter arquivoResultadoFFTBordaDireita, arquivoResultadoFFTBordaEsquerda;
        StreamWriter arquivoPontosBordaDireita, arquivoPontosBordaEsquerda;
        StreamWriter arquivoResultadoFFTTeste;
        StreamWriter arquivoNotasFiltradas;
        double tempo = 0.0;
        // ========================================================
        // Variáveis Locais e Variáveis saída Icônica Classificador Area/Número Buracos:
        HTuple hv_VetInfBurEsq = null, hv_VetInfBurDir = null, hv_NumAreaBur = null;
        HTuple hv_LContEsq = new HTuple(), hv_CContEsq = new HTuple(), hv_VarVazia = new HTuple();
        HTuple hv_CContEsqQt = new HTuple(), hv_LContEsqQt = new HTuple();
        HTuple hv_DetLimAval = new HTuple(), hv_CContEsqFN = new HTuple();
        HTuple hv_IndColEsq = new HTuple(), hv_SIndColEsq = new HTuple();
        HTuple hv_QtIndColEsq = new HTuple(), hv_DetLimEsq = new HTuple();
        HTuple hv_LimLinRegBur = new HTuple(), hv_LRegBurEsq = new HTuple();
        HTuple hv_CRegBurEsq = new HTuple(), hv_NBEsq = new HTuple();
        HTuple hv_Area1E = new HTuple(), hv_AuxL = new HTuple();
        HTuple hv_AuxC = new HTuple(), hv_Area2E = new HTuple();
        HTuple hv_PdiEsqAreaBur = new HTuple();
        HTuple hv_VarTamObj = new HTuple(), hv_VarNumObj = new HTuple();
        HTuple hv_DesPadContEsq = new HTuple(), hv_DesPadContDir = new HTuple();
        HTuple hv_i = new HTuple(), hv_LContDir = new HTuple();
        HTuple hv_CContDir = new HTuple(), hv_PdiEsqAreBur = new HTuple();
        HTuple hv_CContDirQt = new HTuple(), hv_LContDirQt = new HTuple();
        HTuple hv_CContDirFN = new HTuple(), hv_IndColDir = new HTuple();
        HTuple hv_SIndColDir = new HTuple(), hv_QtIndColDir = new HTuple();
        HTuple hv_DetLimDir = new HTuple(), hv_LimLinRegBurDir = new HTuple();
        HTuple hv_LRegBurDir = new HTuple(), hv_CRegBurDir = new HTuple();
        HTuple hv_NBDir = new HTuple(), hv_Area1D = new HTuple();
        HTuple hv_Area2D = new HTuple(), hv_PdiDirAreaBur = new HTuple();
        HTuple hv_MtxInfBurEsq = new HTuple(), hv_MtxInfBurDir = new HTuple();
        HTuple hv_Area1Esq = new HTuple(), hv_Area2Esq = new HTuple();
        HTuple hv_Area1Dir = new HTuple(), hv_Area2Dir = new HTuple();
        HTuple hv_NBurEsq = new HTuple(), hv_NBurDir = new HTuple();
        HTuple hv_MedGeral = new HTuple(), hv_MedNuBur = new HTuple();
        HTuple hv_PesoBur = new HTuple(), hv_MedPond = new HTuple();
        HTuple hv_NotaClaBur = new HTuple();
        // ========================================================

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Image);
        HOperatorSet.GenEmptyObj(out ho_RectangleEsq);
        HOperatorSet.GenEmptyObj(out ho_REsqXLD);
        HOperatorSet.GenEmptyObj(out ho_RectangleDir);
        HOperatorSet.GenEmptyObj(out ho_RDirXLD);
        HOperatorSet.GenEmptyObj(out ho_ImageReducedEsq);
        HOperatorSet.GenEmptyObj(out ho_GrayImageEsq);
        HOperatorSet.GenEmptyObj(out ho_ImageEmphasizeEsq);
        HOperatorSet.GenEmptyObj(out ho_RegionEsq);
        HOperatorSet.GenEmptyObj(out ho_ContoursEsq);
        HOperatorSet.GenEmptyObj(out ho_FullLeftContour);
        HOperatorSet.GenEmptyObj(out ho_ContornoEsq);
        HOperatorSet.GenEmptyObj(out ho_ContornoEsq2);
        HOperatorSet.GenEmptyObj(out ho_SmoothedContoursESQ);
        HOperatorSet.GenEmptyObj(out ho_RegressContoursESQ);
        HOperatorSet.GenEmptyObj(out ho_Line);
        HOperatorSet.GenEmptyObj(out ho_ContoursAffineTrans);
        HOperatorSet.GenEmptyObj(out ho_ImageReducedDir);
        HOperatorSet.GenEmptyObj(out ho_GrayImageDir);
        HOperatorSet.GenEmptyObj(out ho_ImageEmphasizeDir);
        HOperatorSet.GenEmptyObj(out ho_RegionDir);
        HOperatorSet.GenEmptyObj(out ho_ContoursDir);
        HOperatorSet.GenEmptyObj(out ho_FullRightContour);
        HOperatorSet.GenEmptyObj(out ho_ContornoDir);
        HOperatorSet.GenEmptyObj(out ho_SmoothedContoursDIR);
        HOperatorSet.GenEmptyObj(out ho_RegressContoursDIR);
        HOperatorSet.GenEmptyObj(out ho_ContoursAffineTrans1);
        // ========================================================
        // Inicialização Local e saída variáveis icônicas Classificador Area/Número Buracos:
        HOperatorSet.GenEmptyObj(out ho_ContornoEsqAux);
        HOperatorSet.GenEmptyObj(out ho_ContornoEsqRed);
        HOperatorSet.GenEmptyObj(out ho_ContRegBurEsq);
        HOperatorSet.GenEmptyObj(out ho_DomRegBurEsq);
        HOperatorSet.GenEmptyObj(out ho_RegBurEsq);
        HOperatorSet.GenEmptyObj(out ho_BurEsq);
        HOperatorSet.GenEmptyObj(out ho_BurEsqCon);
        HOperatorSet.GenEmptyObj(out ho_ContornoDirAux);
        HOperatorSet.GenEmptyObj(out ho_ContornoDirRed);
        HOperatorSet.GenEmptyObj(out ho_ContRegBurDir);
        HOperatorSet.GenEmptyObj(out ho_DomRegBurDir);
        HOperatorSet.GenEmptyObj(out ho_RegBurDir);
        HOperatorSet.GenEmptyObj(out ho_BurDir);
        HOperatorSet.GenEmptyObj(out ho_BurDirCon);
        // ========================================================
        //double[] notas = new double[1000];
        double[] notaFilt = new double[1905];
        double[] notaFiltInvertida = new double[1905];
        double[] notaFilt2 = new double[1905];
        double[] notaFilt2Invertida = new double[1905];
        double b0 = 4.17488010384953e-04;
        double b1 = 1.66995204153981e-03;
        double b2 = 2.50492806230972e-03;
        double b3 = 1.66995204153981e-03;
        double b4 = 4.17488010384953e-04;
        double a0 = 1.0;
        double a1 = -3.180161762214299;
        double a2 = 3.860126432205552;
        double a3 = -2.111336828008587;
        double a4 = 0.438051966183493;
        int numeroDeNotas = 0;
        int comprimentoNotas;
        int comprimentoVetorNotasFiltradas;
        double[] vetorNotasPeloEspectro = new double[1900];
        double[] vetorNotasPelosBuracos = new double[1900];
        double[] vetorNotasMedias = new double [1900];
        string[] vetorDatas = new string [1900];
        string[] vetorHorarios = new string[1900];


        hv_AcqHandle = hv_acqHandle;
        //Image Acquisition 01: Code generated by Image Acquisition 01
        //HOperatorSet.OpenFramegrabber("GigEVision", 0, 0, 0, 0, 0, 0, "default", -1, "default", -1, "false", "default", "S1143833", 0, -1, out hv_AcqHandle);
        //HOperatorSet.OpenFramegrabber("File", 1, 1, 0, 0, 0, 0, "default", -1, "default", "default", "default", "C:/Users/NOTEBOOK/Documents/pesquisas/gerdau/FORMACAODEESPIRAS/FormacaoVideos/backup17jan2019/video34","default", -1, -1, out hv_AcqHandle);
        HOperatorSet.GrabImageStart(hv_AcqHandle, -1);  
        //HOperatorSet.OpenFramegrabber("File", 1, 1, 0, 0, 0, 0, "default", -1, "default", "default", "default", "C:/Users/Public/Documents/classificadorDeBobinas/FormacaoVideos/formação15127h20.avi", "default", -1, -1, out hv_AcqHandle);
        HOperatorSet.GetFramegrabberParam(hv_AcqHandle, "revision", out hv_Revision);
        ho_Image.Dispose();
        HOperatorSet.GrabImage(out ho_Image, hv_AcqHandle);
        HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);

        // configura o formato dos números das notas que serão impressas em arquivo texto
        NumberFormatInfo nfi = new CultureInfo("en-US", false).NumberFormat;
        nfi.NumberDecimalDigits = 4;
        nfi.NumberGroupSeparator = "";
        

        //Define a região e o corte do xld à esquerda
    
        hv_RectEsq = new HTuple();
        // configuracao da ROI esquerda para uso com arquivos da camera da usina
        //RectEsq:=[490, 127, 1180, 527]
        // RectEsq:=[190, 17, 1188, 527]
        // RectEsq:=[390, 17, 1188, 527]
        hv_RectEsq[0] = 390;// 190;// 490;//100;
        hv_RectEsq[1] = 17; // 127;
        hv_RectEsq[2] = 1188;// 1180;
        hv_RectEsq[3] = 527;
        // configuracao da ROI esquerda para uso com arquivos de videos
        /*hv_RectEsq[0] = 150;
        hv_RectEsq[1] = 27;
        hv_RectEsq[2] = 238;
        hv_RectEsq[3] = 127;
        */
        ho_RectangleEsq.Dispose();
        HOperatorSet.GenRectangle1(out ho_RectangleEsq, hv_RectEsq.TupleSelect(0), hv_RectEsq.TupleSelect(
            1), hv_RectEsq.TupleSelect(2), hv_RectEsq.TupleSelect(3));

        //Define o corte XLD do lado esquerdo
        hv_RectEsqXLD = new HTuple();
        // configuracao da ROI XLD esquerda para uso com arquivos da camera da usina
        //RectEsqXLD:=[520, 127, 1179, 526]
        //RectEsqXLD:=[220, 17, 1187, 526]
        //*RectEsqXLD:=[420, 17, 1187, 526]
        hv_RectEsqXLD[0] = 420;// 520;//130;
        hv_RectEsqXLD[1] = 17;// 127;
        hv_RectEsqXLD[2] = 1187;// 1179;
        hv_RectEsqXLD[3] = 526;
        // configuracao da ROI XLD esquerda para uso com arquivos de videos
        /*
        hv_RectEsqXLD[0] = 180;
        hv_RectEsqXLD[1] = 27;
        hv_RectEsqXLD[2] = 237;
        hv_RectEsqXLD[3] = 126;
        */
        ho_REsqXLD.Dispose();
        HOperatorSet.GenRectangle1(out ho_REsqXLD, hv_RectEsqXLD.TupleSelect(0), hv_RectEsqXLD.TupleSelect(
            1), hv_RectEsqXLD.TupleSelect(2), hv_RectEsqXLD.TupleSelect(3));

        //Define a região à direita
        hv_RectDir = new HTuple();
        // configuracao da ROI direita para uso com arquivos da camera da usina   
        // RectDir:= [490, 1427, 1180, 1910]  RectDir:=[490, 1427, 1410, 1910]
        //RectDir:=[190, 1417, 1188, 1917]
        hv_RectDir[0] = 390;// 490;
        hv_RectDir[1] = 1337;// 1427;
        hv_RectDir[2] = 1188;// 1180;
        hv_RectDir[3] = 1917;// 1910;
        // configuracao da ROI direita para uso com arquivos de videos
        /*    
        hv_RectDir[0] = 150;
        hv_RectDir[1] = 227;
        hv_RectDir[2] = 238;
        hv_RectDir[3] = 280;
        */
        ho_RectangleDir.Dispose();
        HOperatorSet.GenRectangle1(out ho_RectangleDir, hv_RectDir.TupleSelect(0), hv_RectDir.TupleSelect(
            1), hv_RectDir.TupleSelect(2), hv_RectDir.TupleSelect(3));

        //Define o corte XLD do lado direito
        hv_RectDirXLD = new HTuple();
        // configuracao da ROI XLD direita para uso com arquivos da camera da usina
        //RectDirXLD:= [520, 1428, 1179, 1909]  RectDirXLD:=[520, 1428, 1409, 1909]     RectDirXLD:=[520, 1428, 1409, 1909]  
        //RectDirXLD:=[220, 1418, 1187, 1918]
        hv_RectDirXLD[0] = 420;// 520;
        hv_RectDirXLD[1] = 1338;// 1428;
        hv_RectDirXLD[2] = 1187;// 1179;
        hv_RectDirXLD[3] = 1918;// 1909;
        // configuracao da ROI XLD direita para uso com arquivos de videos
        /* 
        hv_RectDirXLD[0] = 180;
        hv_RectDirXLD[1] = 228;
        hv_RectDirXLD[2] = 237;
        hv_RectDirXLD[3] = 279;
        */
        ho_RDirXLD.Dispose();
        HOperatorSet.GenRectangle1(out ho_RDirXLD, hv_RectDirXLD.TupleSelect(0), hv_RectDirXLD.TupleSelect(
            1), hv_RectDirXLD.TupleSelect(2), hv_RectDirXLD.TupleSelect(3));

        //Define o retangulo do topo da imagem para determinar inicio e fim da bobina
        hv_RectTopo = new HTuple();
        // definição da ROI para uso com as imagens da câmera da usina
        //RectTopo:= [430, 328, 809, 1909] RectTopo:=[140, 87, 160, 240]
        hv_RectTopo[0] = 430;// 140; // 430;
        hv_RectTopo[1] = 328;// 87;// 328;
        hv_RectTopo[2] = 809;// 160;// 809;
        hv_RectTopo[3] = 1909;// 240;// 1909;
    
        // definição da ROI para uso com as imagens dos arquivos de vídeos
        /*hv_RectTopo[0] = 160;
        hv_RectTopo[1] = 87;
        hv_RectTopo[2] = 190;
        hv_RectTopo[3] = 240;
        */
        //gen_rectangle1 (RectangleTopo, RectTopo[0], RectTopo[1], RectTopo[2], RectTopo[3])
        //ho_Roi_Dt.Dispose();
        HOperatorSet.GenRectangle1(out ho_Roi_Dt, hv_RectTopo.TupleSelect(0), hv_RectTopo.TupleSelect(
            1), hv_RectTopo.TupleSelect(2), hv_RectTopo.TupleSelect(3));
        
        HDevelopStop();
        //Define quantos frames serão reproduzidos
        hv_MaxImageNum = 100;
        hv_ImageNum = 1;
        
        // =============================================================
        // - INICIALIZAÇÃO VARIÁVEIS CLASSIFICADOR AREA / NUMERO BURACOS
        hv_VetInfBurEsq = new HTuple();
        hv_VetInfBurDir = new HTuple();
        hv_NumAreaBur = 0;
        // =============================================================

        //Logica para deteccao de inicio e fim da formacao de bobinas
        //-> FLAG INICIO PROCESSAMENTO:
        hv_Pdi_Fm_On = 0;
        hv_Hst_Abs_Vec = 0;

        //HOperatorSet.SystemCall("ffplay videoTeste.avi");
        arquivoNotas = File.CreateText("arquivoTemp.txt");
        arquivoNotasFiltradas = File.CreateText("arquivoTempFiltrado.txt");
        //arquivoNotas.Close;
        //while ((int)(new HTuple(hv_ImageNum.TupleLessEqual(hv_MaxImageNum))) != 0)

        /*arquivoResultadoFFTBordaDireita = File.CreateText("C:\\Users\\NOTEBOOK\\Documents\\pesquisas\\gerdau\\FORMACAODEESPIRAS\\FormacaoVideos\\fftResultadoBordaDireita");//\\CodigoEmC#\\HDevelopTemplateWPF\\HDevelopTemplateWPF\\vs2008\\fftResultadoBordaDireita");
        arquivoResultadoFFTBordaEsquerda = File.CreateText("C:\\Users\\NOTEBOOK\\Documents\\pesquisas\\gerdau\\FORMACAODEESPIRAS\\FormacaoVideos\\fftResultadoBordaEsquerda");// CodigoEmC#\\HDevelopTemplateWPF\\HDevelopTemplateWPF\\vs2008\\fftResultadoBordaEsquerda");
        arquivoPontosBordaDireita = File.CreateText("C:\\Users\\NOTEBOOK\\Documents\\pesquisas\\gerdau\\FORMACAODEESPIRAS\\FormacaoVideos\\pontosBordaDireita");// CodigoEmC#\\HDevelopTemplateWPF\\HDevelopTemplateWPF\\vs2008\\pontosBordaDireita");
        arquivoPontosBordaEsquerda = File.CreateText("C:\\Users\\NOTEBOOK\\Documents\\pesquisas\\gerdau\\FORMACAODEESPIRAS\\FormacaoVideos\\pontosBordaEsquerda");// CodigoEmC#\\HDevelopTemplateWPF\\HDevelopTemplateWPF\\vs2008\\pontosBordaEsquerda");
        */
        hv_ImageNum = 0;
        while (true)
        {
            //Próxima Imagem
            //hv_ImageNum = hv_ImageNum + 1;

            /*while ((int)(new HTuple(hv_ImageNum.TupleLessEqual(2))) != 0)
            {
                //Cada chamada de grab_image() lê o próximo frame de imagem do arquivo
                ho_Image.Dispose();
                HOperatorSet.GrabImage(out ho_Image, hv_AcqHandle);
                hv_ImageNum = hv_ImageNum+1;
            }
            */
            if (ho_Image != null)
                ho_Image.Dispose();
            HOperatorSet.GrabImage(out ho_Image, hv_AcqHandle);
            
            //***************************************************************************************************
            //deteccao de inicio e fim da formacao de bobinas
            if (ho_Roi_Dt_Bb != null)
                ho_Roi_Dt_Bb.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_Roi_Dt, out ho_Roi_Dt_Bb);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_Roi_Dt_Bb, HDevWindowStack.GetActive());
            }
            //-> CONVERSAO ESCALA DE CINZA E ENFATIZANDO REGIÃO:
            if (ho_Roi_Dt_Bb_Gs != null)
                ho_Roi_Dt_Bb_Gs.Dispose();

            //HOperatorSet.DispObj(ho_Roi_Dt_Bb, hv_ExpDefaultWinHandle);
            
            HOperatorSet.Rgb1ToGray(ho_Roi_Dt_Bb, out ho_Roi_Dt_Bb_Gs);
            if (ho_Roi_Dt_Bb_Gs_Emp != null)
                ho_Roi_Dt_Bb_Gs_Emp.Dispose();
            HOperatorSet.Emphasize(ho_Roi_Dt_Bb_Gs, out ho_Roi_Dt_Bb_Gs_Emp, 7, 7, 1);
            //-> INTENSIDADE:
            HOperatorSet.Intensity(ho_Roi_Dt_Bb_Gs_Emp, ho_Image, out hv_Roi_Med, out hv_Roi_Var);
            if ((int)(new HTuple(hv_Roi_Med.TupleLess(60))) != 0)
            {
                //sinaliza ausencia de material no leito (final da formacao)
                hv_Pdi_Fm_On = 1;
            }
            else
            {
                //sinaliza a presenca de material no leito
                hv_Pdi_Fm_On = 0;
                // verifica se o atual frame é o primeiro de uma nova bobina
                if (aguardandoMaterial == 1)
                {
                    aguardandoMaterial = 0;
                    data = CurrentTime.Date.ToString("dd_MM_yyyy");
                    horario = DateTime.Now.ToString("HH_mm_ss_fff tt");// DateTime.Now.TimeOfDay C:\Users\Public\Documents\classificadorDeBobinas
                    // C: \Users\NOTEBOOK\Documents\pesquisas\gerdau\FORMACAODEESPIRAS\FormacaoVideos\CodigoEmC#\HDevelopTemplateWPF\HDevelopTemplateWPF\vs2008
                    //!Subsitiuí a linha abaixo
                    //string arquivoNotasNome = "C:\\Users\\Public\\Documents\\classificadorDeBobinas\\FormacaoVideos\\CodigoEmC#\\HDevelopTemplateWPF\\HDevelopTemplateWPF\\vs2008\\";
                    string arquivoNotasNome = folderPath;
                    //"C:\\Users\\NOTEBOOK\\Documents\\pesquisas\\gerdau\\FORMACAODEESPIRAS\\FormacaoVideos\\CodigoEmC#\\HDevelopTemplateWPF\\HDevelopTemplateWPF\\vs2008\\";
                    //"C:\\Users\\Public\\Documents\\classificadorDeBobinas\\FormacaoVideos\\CodigoEmC#\\HDevelopTemplateWPF\\HDevelopTemplateWPF\\vs2008\\";
                    arquivoNotasNome = arquivoNotasNome + "Notas" + "_" + data + "_" + horario + ".txt";
                    arquivoNotas = File.CreateText(arquivoNotasNome);
                    hv_ImageNum = 0;
                    numeroDeNotas = 0;
                    //string arquivoNotasFiltradasNome = "C:\\Users\\Public\\Documents\\classificadorDeBobinas\\FormacaoVideos\\CodigoEmC#\\HDevelopTemplateWPF\\HDevelopTemplateWPF\\vs2008\\";
                    //"C:\\Users\\NOTEBOOK\\Documents\\pesquisas\\gerdau\\FORMACAODEESPIRAS\\FormacaoVideos\\CodigoEmC#\\HDevelopTemplateWPF\\HDevelopTemplateWPF\\vs2008\\";
                    //"C:\\Users\\Public\\Documents\\classificadorDeBobinas\\FormacaoVideos\\CodigoEmC#\\HDevelopTemplateWPF\\HDevelopTemplateWPF\\vs2008\\";
                    //arquivoNotasFiltradasNome = arquivoNotasFiltradasNome + "NotasFiltradas" + "_" + data + "_" + horario + ".txt";
                    //arquivoNotasFiltradas = File.CreateText(arquivoNotasFiltradasNome);
                }
            }
            //Eventos disparados ao final da formacao da bobina e na ausência de material
            if ((int)(new HTuple(hv_Pdi_Fm_On.TupleEqual(1))) != 0)
            {
                //grava o arquivo com o vídeo da bobina
                //compõe o nome do arquivo de vídeo

                // testa se é o primeiro quadro amostrado sem material no leito
                if ( (aguardandoMaterial == 0) && (numeroDeNotas > 5) )
                {
                    //executa ffmpeg para montar o arquivo de video com as imagens gravadas em arquivos png
                    //HOperatorSet.SystemCall("ffmpeg -framerate 33 -pattern_type sequence -start_number 1 -i \"imagemParaVideo%04d.png\" -vcodec mpeg4 teste8.avi");
                    //apaga os arquivos de imagens dos frames amostrados do formador
                    //HOperatorSet.SystemCall("del imagemParaVideo*.png");

                    // ---------------------------------------------------------------------------------------------------------
                    // ------------------ implementa o filtro de fase nula sobre as notas aplicadas à última bobina ------------
                    // ---------------------------------------------------------------------------------------------------------
                    comprimentoNotas = numeroDeNotas;
                    /*b0 = b(1);
                    b1 = b(2);
                    b2 = b(3);
                    b3 = b(4);
                    b4 = b(5);
                    a0 = a(1);
                    a1 = a(2);
                    a2 = a(3);
                    a3 = a(4);
                    a4 = a(5);*/
                    
                    notaFilt[0] = b0 * vetorNotasMedias[0];
                    notaFilt[1] = b0 * vetorNotasMedias[1] + b1 * vetorNotasMedias[0] - a1 * notaFilt[0];
                    notaFilt[2] = b0 * vetorNotasMedias[2] + b1 * vetorNotasMedias[1] + b2 * vetorNotasMedias[0] - a1 * notaFilt[1] - a2 * notaFilt[0];
                    notaFilt[3] = b0 * vetorNotasMedias[3] + b1 * vetorNotasMedias[2] + b2 * vetorNotasMedias[1] + b3 * vetorNotasMedias[0] - a1 * notaFilt[2] - a2 * notaFilt[1] - a3 * notaFilt[0];
                    //comprimentoNotas = length(nota);
                    vetorNotasMedias[comprimentoNotas] = 0;
                    vetorNotasMedias[comprimentoNotas + 1] = 0;
                    vetorNotasMedias[comprimentoNotas + 2] = 0;
                    vetorNotasMedias[comprimentoNotas + 3] = 0;
                    for (int i = 4; i <= (comprimentoNotas-1) ; i++ ) {
                        notaFilt[i] = b0 * vetorNotasMedias[i] + b1 * vetorNotasMedias[i - 1] + b2 * vetorNotasMedias[i - 2] + b3 * vetorNotasMedias[i - 3] + b4 * vetorNotasMedias[i - 4] - a1 * notaFilt[i - 1] - a2 * notaFilt[i - 2] - a3 * notaFilt[i - 3] - a4 * notaFilt[i - 4];
                    }

                    notaFilt[comprimentoNotas] = b1 * vetorNotasMedias[comprimentoNotas-1] + b2 * vetorNotasMedias[comprimentoNotas - 2] + b3 * vetorNotasMedias[comprimentoNotas - 3] + b4 * vetorNotasMedias[comprimentoNotas - 4] - a1 * notaFilt[comprimentoNotas-1] - a2 * notaFilt[comprimentoNotas - 2] - a3 * notaFilt[comprimentoNotas - 3] - a4 * notaFilt[comprimentoNotas - 4];
                    notaFilt[comprimentoNotas + 1] = b2 * vetorNotasMedias[comprimentoNotas-1] + b3 * vetorNotasMedias[comprimentoNotas - 2] + b4 * vetorNotasMedias[comprimentoNotas - 3] - a1 * notaFilt[comprimentoNotas] - a2 * notaFilt[comprimentoNotas - 1] - a3 * notaFilt[comprimentoNotas - 2] - a4 * notaFilt[comprimentoNotas - 3];
                    notaFilt[comprimentoNotas + 2] = b3 * vetorNotasMedias[comprimentoNotas-1] + b4 * vetorNotasMedias[comprimentoNotas - 2] - a1 * notaFilt[comprimentoNotas + 1] - a2 * notaFilt[comprimentoNotas] - a3 * notaFilt[comprimentoNotas - 1] - a4 * notaFilt[comprimentoNotas - 2];
                    notaFilt[comprimentoNotas + 3] = b4 * vetorNotasMedias[comprimentoNotas-1] - a1 * notaFilt[comprimentoNotas + 2] - a2 * notaFilt[comprimentoNotas + 1] - a3 * notaFilt[comprimentoNotas] - a4 * notaFilt[comprimentoNotas-1];
                    notaFilt[comprimentoNotas + 4] = -a1 * notaFilt[comprimentoNotas + 3] - a2 * notaFilt[comprimentoNotas + 2] - a3 * notaFilt[comprimentoNotas + 1] - a4 * notaFilt[comprimentoNotas];
                    notaFilt[comprimentoNotas + 5] = -a1 * notaFilt[comprimentoNotas + 4] - a2 * notaFilt[comprimentoNotas + 3] - a3 * notaFilt[comprimentoNotas + 2] - a4 * notaFilt[comprimentoNotas + 1];
                    notaFilt[comprimentoNotas + 6] = -a1 * notaFilt[comprimentoNotas + 5] - a2 * notaFilt[comprimentoNotas + 4] - a3 * notaFilt[comprimentoNotas + 3] - a4 * notaFilt[comprimentoNotas + 2];
                    notaFilt[comprimentoNotas + 7] = -a1 * notaFilt[comprimentoNotas + 6] - a2 * notaFilt[comprimentoNotas + 5] - a3 * notaFilt[comprimentoNotas + 4] - a4 * notaFilt[comprimentoNotas + 3];

                    comprimentoVetorNotasFiltradas = comprimentoNotas + 7;// length(notaFilt);
                    for ( int i = 0; i <= (comprimentoVetorNotasFiltradas-1); i++) {
                        notaFiltInvertida[i] = notaFilt[comprimentoVetorNotasFiltradas - (i + 1)];
                    }

                    notaFilt2[0] = b0 * notaFiltInvertida[0];
                    notaFilt2[1] = b0 * notaFiltInvertida[1] + b1 * notaFiltInvertida[0] - a1 * notaFilt2[0];
                    notaFilt2[2] = b0 * notaFiltInvertida[2] + b1 * notaFiltInvertida[1] + b2 * notaFiltInvertida[0] - a1 * notaFilt2[1] - a2 * notaFilt2[0];
                    notaFilt2[3] = b0 * notaFiltInvertida[3] + b1 * notaFiltInvertida[2] + b2 * notaFiltInvertida[1] + b3 * notaFiltInvertida[0] - a1 * notaFilt2[2] - a2 * notaFilt2[1] - a3 * notaFilt2[0];

                    for ( int i = 4; i <= comprimentoVetorNotasFiltradas; i++ ) { // length(notaFiltInvertida) {
                        notaFilt2[i] = b0 * notaFiltInvertida[i] + b1 * notaFiltInvertida[i - 1] + b2 * notaFiltInvertida[i - 2] + b3 * notaFiltInvertida[i - 3] + b4 * notaFiltInvertida[i - 4] - a1 * notaFilt2[i - 1] - a2 * notaFilt2[i - 2] - a3 * notaFilt2[i - 3] - a4 * notaFilt2[i - 4];
                    }

                    //comprimentoVetorNotasFiltradas = length(notaFilt2);
                    for ( int i = 0; i <= (comprimentoVetorNotasFiltradas-1); i++ ) { 
                      notaFilt2Invertida[i] = notaFilt2[comprimentoVetorNotasFiltradas - (i + 1)];
                    }

                    /*
                    for (int i = 0 ; i < notaFilt2Invertida.Length ; i++)
                    {
                        arquivoNotasFiltradas.WriteLine(notaFilt2Invertida[i].ToString("N", nfi));
                        //arquivoPontosBordaDireita.WriteLine(y[i].real.ToString("N", nfi) + " " + y[i].imag.ToString("N", nfi));
                    }*/
                    for (int i = 0; i < comprimentoNotas; i++)
                    {

                        //arquivoNotasFiltradas.WriteLine(notaFilt2Invertida[i].ToString("N", nfi));
                        //arquivoPontosBordaDireita.WriteLine(y[i].real.ToString("N", nfi) + " " + y[i].imag.ToString("N", nfi));
                        if (notaFilt2Invertida[i] < 0)
                            notaFilt2Invertida[i] = 0;
                        arquivoNotas.WriteLine(vetorDatas[i] + "  " + vetorHorarios[i] + "  " + vetorNotasPeloEspectro[i].ToString("N", nfi) + "  " + vetorNotasPelosBuracos[i].ToString("N", nfi) + "  " + vetorNotasMedias[i].ToString("N", nfi) + "  " + notaFilt2Invertida[i].ToString("N", nfi) + "  " +comprimentoNotas.ToString("N", nfi));
                    }
                    //arquivoNotasFiltradas.Close();
                    // ----------------------------------------------------------------------------------------------------
                    // ----------------------------- fim do filtro de fase nula ------------------------------------------
                    // ---------------------------------------------------------------------------------------------------


                    //fecha o arquivo txt com as notas das bordas
                    arquivoNotas.Close();
                    // sinaliza que o sistema está esperando a próxima bobina
                    aguardandoMaterial = 1;
                    // reinicializa o contador de quadros
                    hv_ImageNum = 0;
                }

            }
            //if (hv_ImageNum == 199)
            //    hv_ImageNum = hv_ImageNum;

            //Eventos disparados durante a formacao da bobina
            if ((int)(new HTuple(hv_Pdi_Fm_On.TupleEqual(0))) != 0)
            {
                //ho_Image.Dispose();
                //HOperatorSet.GrabImage(out ho_Image, hv_AcqHandle);
                hv_ImageNum = hv_ImageNum + 1;
                //**************************************************************************************************
                //gravação da imagem adquirida da câmera
                /*
                hv_nomeArquivoVideoSaida = "C:\\Users\\Administrador\\Documents\\classificadorDeBobinas\\FormacaoVideos\\CodigoEmC#\\HDevelopTemplateWPF\\HDevelopTemplateWPF\\vs2008\\imagemParaVideo";
                HOperatorSet.TupleString(hv_ImageNum, "04d", out hv_ImageNumString);
                HOperatorSet.TupleAdd(hv_nomeArquivoVideoSaida, hv_ImageNumString, out hv_nomeArquivoVideoSaida);
                HOperatorSet.TupleAdd(hv_nomeArquivoVideoSaida, ".png", out hv_nomeArquivoVideoSaida);
                HOperatorSet.WriteImage(ho_Image, "png fastest", 255, hv_nomeArquivoVideoSaida);
                */
                /*while ((int)(new HTuple(hv_ImageNum.TupleLessEqual(2))) != 0)
                {
                    //Cada chamada de grab_image() lê o próximo frame de imagem do arquivo
                    ho_Image.Dispose();
                    HOperatorSet.GrabImage(out ho_Image, hv_AcqHandle);
                    hv_ImageNum = hv_ImageNum+1;
                }
                */


                //**************************************************************************************************
                //Tratamento da imagem à Esquerda
                ho_ImageReducedEsq.Dispose();
                HOperatorSet.ReduceDomain(ho_Image, ho_RectangleEsq, out ho_ImageReducedEsq
                  );
                ho_GrayImageEsq.Dispose();
                HOperatorSet.Rgb1ToGray(ho_ImageReducedEsq, out ho_GrayImageEsq);
                ho_ImageEmphasizeEsq.Dispose();
                HOperatorSet.Emphasize(ho_GrayImageEsq, out ho_ImageEmphasizeEsq, 7, 7, 0.2);

                //Filtro de cinza
                HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "black");
                ho_RegionEsq.Dispose();
                HOperatorSet.Threshold(ho_ImageEmphasizeEsq, out ho_RegionEsq, 140, 255);

                //Gera um contorno xld da região
                ho_ContoursEsq.Dispose();
                HOperatorSet.GenContourRegionXld(ho_RegionEsq, out ho_ContoursEsq, "center");

                HOperatorSet.DispObj(ho_ContoursEsq, hv_ExpDefaultWinHandle);
                //HOperatorSet.DispObj(hv_RectTopo, hv_ExpDefaultWinHandle);
                HOperatorSet.DispObj(ho_Image, hv_ExpDefaultWinHandle);


                //Separa o contorno da região à esquerda e o filtra por comprimento
                HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "white");
                ho_FullLeftContour.Dispose();
                HOperatorSet.ClipContoursXld(ho_ContoursEsq, out ho_FullLeftContour, hv_RectEsqXLD.TupleSelect(
                  0), hv_RectEsqXLD.TupleSelect(1), hv_RectEsqXLD.TupleSelect(2), hv_RectEsqXLD.TupleSelect(
                  3));
                ho_ContornoEsq.Dispose();
                HOperatorSet.SelectContoursXld(ho_FullLeftContour, out ho_ContornoEsq, "contour_length",
                  70, 3000, -0.5, 0.5);

                HOperatorSet.DispObj(ho_ContornoEsq, hv_ExpDefaultWinHandle);

                //ho_ContornoEsq2.Dispose();
                //HOperatorSet.SelectContoursXld(ho_ContornoEsq, out ho_ContornoEsq2, "open", 50, 100, -0.5, 0.5);

                //ho_ContornoEsq.Dispose();
                //ho_ContornoEsq = ho_ContornoEsq2.CopyObj(1,-1);

                //Código para selecionar a maior dentre as bordas identificadas do lado esquerdo
                hv_ContornoEsqMax = 0;
                HOperatorSet.LengthXld(ho_ContornoEsq, out hv_comprimentosBordaEsquerda);
                HOperatorSet.TupleLength(hv_comprimentosBordaEsquerda, out hv_tamanhoVetorBordasEsquerda);
                if (hv_tamanhoVetorBordasEsquerda != 0)
                {
                    //hv_tamanhoVetorBordasEsquerda = 0;


                    if ((int)(new HTuple(hv_tamanhoVetorBordasEsquerda.TupleGreater(1))) != 0)
                    {
                        HTuple end_val100 = hv_tamanhoVetorBordasEsquerda - 1;
                        HTuple step_val100 = 1;
                        for (hv_index = 0; hv_index.Continue(end_val100, step_val100); hv_index = hv_index.TupleAdd(step_val100))
                        {
                            if ((int)(new HTuple(((hv_comprimentosBordaEsquerda.TupleSelect(hv_index))).TupleGreater(
                                hv_ContornoEsqMax))) != 0)
                            {
                                hv_indexMaiorContorno = hv_index.Clone();
                                hv_ContornoEsqMax = hv_comprimentosBordaEsquerda.TupleSelect(hv_index);
                            }
                        }
                        if (ho_ContornoEsqAux != null)
                            ho_ContornoEsqAux.Dispose();
                        HOperatorSet.SelectContoursXld(ho_ContornoEsq, out ho_ContornoEsqAux, "contour_length",
                            hv_ContornoEsqMax, 3000, -0.5, 0.5);
                        ho_ContornoEsq.Dispose();
                        ho_ContornoEsq = ho_ContornoEsqAux.CopyObj(1, -1);
                    }



                    //==========================================================================
                    //--> AJUSTE DO CONTORNO (ELIMINAR PONTOS = AO LADO ESQUERDO DA RectEsqXLD):
                    //- Indices dos pontos do contorno:
                    HOperatorSet.GetContourXld(ho_ContornoEsq, out hv_LContEsq, out hv_CContEsq);
                    //- Teste Contorno <ContornoEsq> Vazio:
                    HOperatorSet.TupleType(hv_LContEsq, out hv_VarVazia);
                    if ((int)(new HTuple(hv_VarVazia.TupleEqual(15))) != 0)
                    {
                        if (hv_LContEsq == null)
                            hv_LContEsq = new HTuple();
                        hv_LContEsq[0] = -1;
                    }
                    else if ((int)(new HTuple(hv_VarVazia.TupleEqual(2))) != 0)
                    {
                        //- Quantidade de índices de Coluna do Contorno:
                        HOperatorSet.TupleLength(hv_CContEsq, out hv_CContEsqQt);
                        //- Quantidade de índices de Linhas do Contorno:
                        HOperatorSet.TupleLength(hv_LContEsq, out hv_LContEsqQt);
                    }
                    if ((int)(new HTuple(((hv_LContEsq.TupleSelect(0))).TupleEqual(hv_RectEsqXLD.TupleSelect(
                        2)))) != 0)
                    {
                        //- Cálculo 25% Qt Colunas do Contorno:
                        HOperatorSet.TupleCeil(hv_CContEsqQt * 0.90, out hv_DetLimAval);
                        //- Separa 25% Índices Contorno
                        HOperatorSet.TupleFirstN(hv_CContEsq, hv_DetLimAval, out hv_CContEsqFN);
                        //- Verifica Qt Índices do TRECHO DO Contorno com = valor de coluna Dir da RectEsqXLD
                        HOperatorSet.TupleFind(hv_CContEsqFN, hv_RectEsqXLD.TupleSelect(1), out hv_IndColEsq);
                        HOperatorSet.TupleSum(hv_IndColEsq, out hv_SIndColEsq);
                        HOperatorSet.TupleLength(hv_IndColEsq, out hv_QtIndColEsq);
                        //- Se há índices Col Esq Contorno = Col RectEsqXLD
                        if ((int)(new HTuple(hv_SIndColEsq.TupleGreaterEqual(0))) != 0)
                        {
                            //- Porcentagem Qtde índices Col Esq Coincidentes
                            hv_DetLimEsq = ((hv_QtIndColEsq.TupleReal()) / (hv_DetLimAval.TupleReal()
                                )) * 100;
                            //- Se não há índices Col Esq Contorno = Col Esq RectEsqXLD
                        }
                        else if ((int)(new HTuple(hv_SIndColEsq.TupleLess(0))) != 0)
                        {
                            //- Não há índices Col Esq Coincidentes
                            hv_DetLimEsq = -1;
                        }
                        //- Se a quantidade de índices coincidentes > 20%
                        if ((int)(new HTuple(hv_DetLimEsq.TupleGreater(20))) != 0)
                        {
                            hv_VarTamObj = 100;
                            ho_ContornoEsqRed.Dispose();
                            HOperatorSet.ClipContoursXld(ho_ContornoEsq, out ho_ContornoEsqRed, hv_RectEsqXLD.TupleSelect(
                                0), hv_RectEsqXLD.TupleSelect(1), hv_LContEsq.TupleSelect(hv_QtIndColEsq - 1),
                                hv_RectEsqXLD.TupleSelect(3));
                            ho_ContornoEsqAux.Dispose();
                            HOperatorSet.SelectContoursXld(ho_ContornoEsqRed, out ho_ContornoEsqAux,
                                "open", hv_VarTamObj, 3000, -0.5, 0.5);
                            //- Verifica Qtde Objetos em <ContornoEsqAux>:
                            HOperatorSet.CountObj(ho_ContornoEsqAux, out hv_VarNumObj);
                            //- Altera a Seleção para Manter o Objeto Maior:
                            while ((int)(new HTuple(hv_VarNumObj.TupleGreater(1))) != 0)
                            {
                                hv_VarTamObj = hv_VarTamObj + 1;
                                ho_ContornoEsqAux.Dispose();
                                HOperatorSet.SelectContoursXld(ho_ContornoEsqRed, out ho_ContornoEsqAux,
                                    "open", hv_VarTamObj, 3000, -0.5, 0.5);
                                HOperatorSet.CountObj(ho_ContornoEsqAux, out hv_VarNumObj);
                            }
                            ho_ContornoEsq.Dispose();
                            ho_ContornoEsq = ho_ContornoEsqAux.CopyObj(1, -1);
                        }
                        //A detecção do contorno ter pontos no lado direito da ROI RectEsqXLD
                        //não foi implementada devido à baixíssima probabilidade desse evento
                        //------------------------------------------------------------------------------
                        //--> DETECÇÃO DA ÁREA DOS BURACOS NA IMAGEM DO FORMADOR - LADO ESQUERDO
                        //- Delimitando Região RectEsqXLD: Contorno até borda direita da ROI Esq
                        HOperatorSet.GetContourXld(ho_ContornoEsq, out hv_LContEsq, out hv_CContEsq);
                        HOperatorSet.TupleLength(hv_CContEsq, out hv_CContEsqQt);
                        //- Teste Contorno Cortado vazio (Elimina Frame):
                        HOperatorSet.TupleType(hv_CContEsq, out hv_VarVazia);
                        if ((int)(new HTuple(hv_VarVazia.TupleEqual(2))) != 0)
                        {
                            //- Parâmetro Limitador Linhas Região Buracos (NECESSITA CALIBRAÇÃO)
                            hv_LimLinRegBur = 40;
                            //- Delimitando a Região:
                            HOperatorSet.TupleFirstN(hv_LContEsq, hv_CContEsqQt - hv_LimLinRegBur, out hv_LContEsq);
                            HOperatorSet.TupleFirstN(hv_CContEsq, hv_CContEsqQt - hv_LimLinRegBur, out hv_CContEsq);
                            hv_LRegBurEsq = new HTuple();
                            hv_LRegBurEsq = hv_LRegBurEsq.TupleConcat(hv_LContEsq);
                            hv_LRegBurEsq = hv_LRegBurEsq.TupleConcat(hv_LContEsq.TupleSelect(
                                hv_CContEsqQt - hv_LimLinRegBur));
                            hv_LRegBurEsq = hv_LRegBurEsq.TupleConcat(hv_LContEsq.TupleSelect(
                                0));
                            hv_LRegBurEsq = hv_LRegBurEsq.TupleConcat(hv_LContEsq.TupleSelect(
                                0));
                            hv_CRegBurEsq = new HTuple();
                            hv_CRegBurEsq = hv_CRegBurEsq.TupleConcat(hv_CContEsq);
                            hv_CRegBurEsq = hv_CRegBurEsq.TupleConcat(((hv_RectEsqXLD.TupleSelect(
                                3))).TupleReal());
                            hv_CRegBurEsq = hv_CRegBurEsq.TupleConcat(((hv_RectEsqXLD.TupleSelect(
                                3))).TupleReal());
                            hv_CRegBurEsq = hv_CRegBurEsq.TupleConcat(hv_CContEsq.TupleSelect(
                                0));
                            //- Gerando a região:
                            ho_ContRegBurEsq.Dispose();
                            HOperatorSet.GenRegionPolygon(out ho_ContRegBurEsq, hv_LRegBurEsq, hv_CRegBurEsq);
                            //- Preenchendo a região:
                            ho_DomRegBurEsq.Dispose();
                            HOperatorSet.FillUp(ho_ContRegBurEsq, out ho_DomRegBurEsq);
                            ho_RegBurEsq.Dispose();
                            HOperatorSet.ReduceDomain(ho_RegionEsq, ho_DomRegBurEsq, out ho_RegBurEsq
                                );
                            //- Gerando Imagem Apenas com Buracos:
                            ho_BurEsq.Dispose();
                            HOperatorSet.Difference(ho_DomRegBurEsq, ho_RegBurEsq, out ho_BurEsq);
                            //- Gerando região conexa com Image dos Buracos:
                            ho_BurEsqCon.Dispose();
                            HOperatorSet.Connection(ho_BurEsq, out ho_BurEsqCon);
                            //- Contanto Número de Buracos:
                            HOperatorSet.CountObj(ho_BurEsqCon, out hv_NBEsq);
                            //- Calculando área Região Apenas com Buracos:
                            HOperatorSet.AreaCenter(ho_BurEsq, out hv_Area1E, out hv_AuxL, out hv_AuxC);
                            //- Calculando área Buracos ROI:
                            HOperatorSet.AreaHoles(ho_RegBurEsq, out hv_Area2E);
                            //- PDI Região Esquerda realizdo:
                            hv_PdiEsqAreaBur = 1;
                        }
                        else if ((int)(new HTuple(hv_VarVazia.TupleEqual(15))) != 0)
                        {
                            hv_PdiEsqAreaBur = 0;
                        }
                        //------------------------------------------------------------------------------
                    }
                    else
                    {
                        hv_PdiEsqAreaBur = 0;
                    }
                    //- FIM ANALISE AREA / NUMERO BURADOS RectEsqXLD
                    //==========================================================================









                    //Fim do código para identificação da maior dentre as bordas identificadas do lado esquerdo
                    ho_SmoothedContoursESQ.Dispose();
                    HOperatorSet.SmoothContoursXld(ho_ContornoEsq, out ho_SmoothedContoursESQ,
                      7);
                    HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "red");
                    HOperatorSet.SetLineWidth(hv_ExpDefaultWinHandle, 2);
                    HOperatorSet.DispObj(ho_SmoothedContoursESQ, hv_ExpDefaultWinHandle);

                    //Calcula a regressão linear para o contorno à esquerda
                    ho_RegressContoursESQ.Dispose();
                    HOperatorSet.RegressContoursXld(ho_SmoothedContoursESQ, out ho_RegressContoursESQ, "no", 1);
                    HOperatorSet.GetRegressParamsXld(ho_RegressContoursESQ, out hv_Length, out hv_Nx, out hv_Ny, out hv_Dist, out hv_Fpx, out hv_Fpy, out hv_Lpx, out hv_Lpy, out hv_Mean, out hv_Deviation);
                    HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "green");
                    HOperatorSet.DispArrow(hv_ExpDefaultWinHandle, hv_Fpy, hv_Fpx, hv_Lpy, hv_Lpx, 1);

                    //Calcula a orientação da regressão linear à esquerda e rotaciona o contorno até 90°
                    HOperatorSet.LineOrientation(hv_Fpy, hv_Fpx, hv_Lpy, hv_Lpx, out hv_PhiEsq);
                    ho_Line.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_Line, hv_Fpy.TupleConcat(hv_Lpy),
                      hv_Fpx.TupleConcat(hv_Lpx));
                    HOperatorSet.DispObj(ho_Line, hv_ExpDefaultWinHandle);
                    hv_RotacaoEsq = -hv_PhiEsq;
                    //1.57-PhiEsq

                    HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                    HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, hv_RotacaoEsq, hv_Fpy, hv_Fpx,
                      out hv_HomMat2DRotate);
                    ho_ContoursAffineTrans.Dispose();
                    HOperatorSet.AffineTransContourXld(ho_RegressContoursESQ, out ho_ContoursAffineTrans,
                      hv_HomMat2DRotate);
                    HOperatorSet.DispObj(ho_ContoursAffineTrans, hv_ExpDefaultWinHandle);
                    HOperatorSet.GetContourXld(ho_ContoursAffineTrans, out hv_Row, out hv_Col);



                    //for index := 0 to |Row|-1 by 1
                    //fwrite_string (arquivoSaida1, [Col[index],' ' ,Row[index]])
                    //fnew_line (arquivoSaida1)
                    //endfor

                    //close_file (arquivoSaida1)

                    //***************************************************************************************************************
                    //TRATAMENTO DA IMAGEM A DIREITA

                    //HOperatorSet.OpenFile("bordaNota7_algumasEspirasSalientes_15_12_7h20_bordaDireita", "output", out hv_arquivoSaida1);
                    //open_file ('bordaNota7_algumasEspirasSalientesEMuitoDesorganizadas_14_12_6h24_bordaDireita', 'output', arquivoSaida1)
                    //open_file ('bordaNota6_algumasEspirasSalientesEMuitoDesorganizadas_15_12_10h03_bordaDireita', 'output', arquivoSaida1)
                    //open_file ('bordaNota6_algumasEspirasSalientesEMuitoDesorganizadas_15_12_10h03_bordaDireita', 'output', arquivoSaida1)
                    //open_file ('bordaNota4_algumasEspirasSalientesEMuitoDesorganizadas_15_12_12h11_bordaDireita', 'output', arquivoSaida1)
                    //open_file ('bordaNota4_algumasEspirasSalientesEDeslocamentoRegiãoEspiras_14_12_7h39_bordaDireita', 'output', arquivoSaida1)
                    //open_file ('bordaNota3_algumasEspirasSalientesEMuitoDesorganizadas_14_12_23h29_bordaDireita', 'output', arquivoSaida1)
                    ho_ImageReducedDir.Dispose();
                    HOperatorSet.ReduceDomain(ho_Image, ho_RectangleDir, out ho_ImageReducedDir
                      );
                    ho_GrayImageDir.Dispose();
                    HOperatorSet.Rgb1ToGray(ho_ImageReducedDir, out ho_GrayImageDir);
                    ho_ImageEmphasizeDir.Dispose();
                    HOperatorSet.Emphasize(ho_GrayImageDir, out ho_ImageEmphasizeDir, 7, 7, 0.2);

                    //Filtro de cinza
                    //dev_set_color ('black')
                    ho_RegionDir.Dispose();
                    HOperatorSet.Threshold(ho_GrayImageDir, out ho_RegionDir, 140, 255);

                    //Gera um contorno XLD da região direita
                    ho_ContoursDir.Dispose();
                    HOperatorSet.GenContourRegionXld(ho_RegionDir, out ho_ContoursDir, "center");

                    //Separa o contorno da região à direita e o filtra por comprimento
                    //dev_set_color ('white')
                    ho_FullRightContour.Dispose();
                    HOperatorSet.ClipContoursXld(ho_ContoursDir, out ho_FullRightContour, hv_RectDirXLD.TupleSelect(
                      0), hv_RectDirXLD.TupleSelect(1), hv_RectDirXLD.TupleSelect(2), hv_RectDirXLD.TupleSelect(
                      3));
                    ho_ContornoDir.Dispose();
                    HOperatorSet.SelectContoursXld(ho_FullRightContour, out ho_ContornoDir, "contour_length",
                      70, 3000, -0.5, 0.5);

                    //Código para selecionar a maior dentre as bordas identificadas do lado direito
                    hv_ContornoDirMax = 0;
                    HOperatorSet.LengthXld(ho_ContornoDir, out hv_comprimentosBordaDireita);
                    HOperatorSet.TupleLength(hv_comprimentosBordaDireita, out hv_tamanhoVetorBordasDireita);
                    if ((int)(new HTuple(hv_tamanhoVetorBordasDireita.TupleEqual(0))) != 0)
                    {
                        hv_ContornoDirMax = hv_ContornoDirMax;
                    }
                    //hv_i = hv_comprimentosBordaDireita.TupleSelect(0);
                    if ((int)(new HTuple(hv_tamanhoVetorBordasDireita.TupleGreater(0))) != 0)
                    {
                        HTuple end_val176 = hv_tamanhoVetorBordasDireita - 1;
                        HTuple step_val176 = 1;
                        for (hv_index = 0; hv_index.Continue(end_val176, step_val176); hv_index = hv_index.TupleAdd(step_val176))
                        {
                            if ((int)(new HTuple(((hv_comprimentosBordaDireita.TupleSelect(hv_index))).TupleGreater(
                             hv_ContornoDirMax))) != 0)
                            {
                                hv_indexMaiorContorno = hv_index.Clone();
                                hv_ContornoDirMax = hv_comprimentosBordaDireita.TupleSelect(hv_index);
                            }
                        }
                        //ho_ContornoDirAux.Dispose();
                        HOperatorSet.SelectContoursXld(ho_ContornoDir, out ho_ContornoDirAux, "contour_length",
                            hv_ContornoDirMax, 3000, -0.5, 0.5);
                        if (ho_ContornoDirAux != null)
                            ho_ContornoDir.Dispose();
                        ho_ContornoDir = ho_ContornoDirAux.CopyObj(1, -1);



                        //==========================================================================
                        //-------------------------------------------------------------------------
                        //--> AJUSTE DO CONTORNO (ELIMINAR PONTOS = AO LADO DIREITO DA RectDirXLD):
                        //- Indices dos pontos do contorno:
                        HOperatorSet.GetContourXld(ho_ContornoDir, out hv_LContDir, out hv_CContDir);
                        //- Teste Contorno <ContornoDir> Vazio:
                        HOperatorSet.TupleType(hv_LContDir, out hv_VarVazia);
                        if ((int)(new HTuple(hv_VarVazia.TupleEqual(15))) != 0)
                        {
                            //LContEsq[0] := -1
                            hv_PdiEsqAreBur = 0;
                        }
                        else if ((int)(new HTuple(hv_VarVazia.TupleEqual(2))) != 0)
                        {
                            //- Quantidade de índices de Coluna do Contorno:
                            HOperatorSet.TupleLength(hv_CContDir, out hv_CContDirQt);
                            //- Quantidade de índices de Linhas do Contorno:
                            HOperatorSet.TupleLength(hv_LContDir, out hv_LContDirQt);
                        }
                        if ((int)(new HTuple(hv_PdiEsqAreaBur.TupleEqual(1))) != 0)
                        {
                            //*         if (LContDir[LContDirQt-1] == RectDirXLD[2])
                            //- Cálculo 25% Qt Colunas do Contorno:
                            HOperatorSet.TupleCeil(hv_CContDirQt * 0.25, out hv_DetLimAval);
                            //- Separa 25% Índices Contorno
                            HOperatorSet.TupleLastN(hv_CContDir, hv_DetLimAval, out hv_CContDirFN);
                            //- Verifica Qt Índices do TRECHO DO Contorno com = valor de coluna Dir da RectDirXLD
                            HOperatorSet.TupleFind(hv_CContDirFN, hv_RectDirXLD.TupleSelect(3), out hv_IndColDir);
                            HOperatorSet.TupleSum(hv_IndColDir, out hv_SIndColDir);
                            HOperatorSet.TupleLength(hv_IndColDir, out hv_QtIndColDir);
                            //- Se há índices Col Dir Contorno = Col RectDirXLD
                            if ((int)(new HTuple(hv_SIndColDir.TupleGreaterEqual(0))) != 0)
                            {
                                //- Porcentagem Qtde índices Col Dir Coincidentes
                                hv_DetLimDir = ((hv_QtIndColDir.TupleReal()) / (hv_DetLimAval.TupleReal()
                                    )) * 100;
                                //- Se não há índices Col Dir Contorno = Col Dir RectDirXLD
                            }
                            else if ((int)(new HTuple(hv_SIndColDir.TupleLess(0))) != 0)
                            {
                                //- Não há índices Col Dir Coincidentes
                                hv_DetLimDir = -1;
                            }
                            //- Se a quantidade de índices coincidentes > 20%
                            if ((int)(new HTuple(hv_DetLimDir.TupleGreater(20))) != 0)
                            {
                                hv_VarTamObj = 100;
                                ho_ContornoDirRed.Dispose();
                                HOperatorSet.ClipContoursXld(ho_ContornoDir, out ho_ContornoDirRed, hv_RectDirXLD.TupleSelect(
                                    0), hv_RectDirXLD.TupleSelect(1), (hv_RectDirXLD.TupleSelect(2)) - hv_QtIndColDir,
                                    hv_CContDir.TupleSelect((hv_CContDirQt - hv_QtIndColDir) - 1));
                                ho_ContornoDirAux.Dispose();
                                HOperatorSet.SelectContoursXld(ho_ContornoDirRed, out ho_ContornoDirAux,
                                    "open", 100, 3000, -0.5, 0.5);
                                //- Verifica Qtde Objetos em <ContornoDirAux>:
                                HOperatorSet.CountObj(ho_ContornoDirAux, out hv_VarNumObj);
                                //- Altera a Seleção para Manter o Objeto Maior:
                                while ((int)(new HTuple(hv_VarNumObj.TupleGreater(1))) != 0)
                                {
                                    hv_VarTamObj = hv_VarTamObj + 1;
                                    ho_ContornoDirAux.Dispose();
                                    HOperatorSet.SelectContoursXld(ho_ContornoDirRed, out ho_ContornoDirAux,
                                        "open", hv_VarTamObj, 3000, -0.5, 0.5);
                                    HOperatorSet.CountObj(ho_ContornoDirAux, out hv_VarNumObj);
                                }
                                ho_ContornoDir.Dispose();
                                ho_ContornoDir = ho_ContornoDirRed.CopyObj(1, -1);
                            }
                            //A detecção do contorno ter pontos no lado esquerdo da ROI RectDirXLD
                            //não foi implementada devido a baixíssima probabilidade desse evento.
                            //------------------------------------------------------------------------------
                            //--> DETECÇÃO DA ÁREA DOS BURACOS NA IMAGEM DO FORMADOR - LADO DIREITO
                            //- Delimitando Região RectDirXLD: Contorno até borda Esquerda da ROI Dir
                            HOperatorSet.GetContourXld(ho_ContornoDir, out hv_LContDir, out hv_CContDir);
                            HOperatorSet.TupleType(hv_CContDir, out hv_VarVazia);
                            if ((int)(new HTuple(hv_VarVazia.TupleEqual(2))) != 0)
                            {
                                //- Parâmetro Limitador Linhas Região Buracos (NECESSITA CALIBRAÇÃO)
                                hv_LimLinRegBurDir = 40;
                                //- Delimitando a região:
                                HOperatorSet.TupleLastN(hv_LContDir, hv_LimLinRegBurDir, out hv_LContDir);
                                HOperatorSet.TupleLastN(hv_CContDir, hv_LimLinRegBurDir, out hv_CContDir);
                                hv_LRegBurDir = new HTuple();
                                hv_LRegBurDir = hv_LRegBurDir.TupleConcat(hv_LContDir);
                                hv_LRegBurDir = hv_LRegBurDir.TupleConcat(((hv_RectDirXLD.TupleSelect(
                                    2))).TupleReal());
                                hv_LRegBurDir = hv_LRegBurDir.TupleConcat(hv_LContDir.TupleSelect(
                                    0));
                                hv_LRegBurDir = hv_LRegBurDir.TupleConcat(hv_LContDir.TupleSelect(
                                    0));
                                hv_CRegBurDir = new HTuple();
                                hv_CRegBurDir = hv_CRegBurDir.TupleConcat(hv_CContDir);
                                hv_CRegBurDir = hv_CRegBurDir.TupleConcat(((hv_RectDirXLD.TupleSelect(
                                    1))).TupleReal());
                                hv_CRegBurDir = hv_CRegBurDir.TupleConcat(((hv_RectDirXLD.TupleSelect(
                                    1))).TupleReal());
                                hv_CRegBurDir = hv_CRegBurDir.TupleConcat(hv_CContDir.TupleSelect(
                                    0));
                                //- Gerando nova região:
                                ho_ContRegBurDir.Dispose();
                                HOperatorSet.GenRegionPolygon(out ho_ContRegBurDir, hv_LRegBurDir, hv_CRegBurDir);
                                //- Preenchendo a região:
                                ho_DomRegBurDir.Dispose();
                                HOperatorSet.FillUp(ho_ContRegBurDir, out ho_DomRegBurDir);
                                ho_RegBurDir.Dispose();
                                HOperatorSet.ReduceDomain(ho_RegionDir, ho_DomRegBurDir, out ho_RegBurDir
                                    );
                                //- Gerando Imagem Apenas com Buracos:
                                ho_BurDir.Dispose();
                                HOperatorSet.Difference(ho_DomRegBurDir, ho_RegBurDir, out ho_BurDir);
                                //- Gerando região conexa com Image dos Buracos:
                                ho_BurDirCon.Dispose();
                                HOperatorSet.Connection(ho_BurDir, out ho_BurDirCon);
                                //- Contanto Número de Buracos:
                                HOperatorSet.CountObj(ho_BurDirCon, out hv_NBDir);
                                //- Calculando área Região Apenas com Buracos:
                                HOperatorSet.AreaCenter(ho_BurDir, out hv_Area1D, out hv_AuxL, out hv_AuxC);
                                //- Calculando área Buracos ROI:
                                HOperatorSet.AreaHoles(ho_RegBurDir, out hv_Area2D);
                                //- PDI Região Direita Realizado:
                                hv_PdiDirAreaBur = 1;
                            }
                            else if ((int)(new HTuple(hv_VarVazia.TupleEqual(15))) != 0)
                            {
                                hv_PdiDirAreaBur = 0;
                            }
                            //------------------------------------------------------------------------------
                        }
                        else
                        {
                            hv_PdiDirAreaBur = 0;
                        }
                        //- FIM ANALISE AREA / NUMERO BURADOS RectDirXLD
                        //==========================================================================







                        //Fim do código para identificação da maior dentre as bordas identificadas do lado direito
                        ho_SmoothedContoursDIR.Dispose();
                        HOperatorSet.SmoothContoursXld(ho_ContornoDir, out ho_SmoothedContoursDIR,
                          7);
                        //dev_set_color ('red')
                        //dev_display (SmoothedContoursDIR)

                        //Calcula a regressão linear  para o contorno à direita
                        ho_RegressContoursDIR.Dispose();
                        HOperatorSet.RegressContoursXld(ho_SmoothedContoursDIR, out ho_RegressContoursDIR,
                        "no", 1);
                        HOperatorSet.GetRegressParamsXld(ho_RegressContoursDIR, out hv_Length1, out hv_Nx1,
                          out hv_Ny1, out hv_Dist1, out hv_Fpx1, out hv_Fpy1, out hv_Lpx1, out hv_Lpy1,
                          out hv_Mean1, out hv_Deviation1);
                        //dev_set_color ('green')
                        //disp_arrow (200000, Fpy1, Fpx1, Lpy1, Lpx1, 1)

                        //Calcula a orientação da regressão linear à direita e rotaciona o contorno até -90°
                        HOperatorSet.LineOrientation(hv_Fpy1, hv_Fpx1, hv_Lpy1, hv_Lpx1, out hv_PhiDir);
                        hv_RotacaoDir = -hv_PhiDir;
                        //1.57-PhiDir

                        HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity1);
                        HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity1, hv_RotacaoDir, hv_Fpy1, hv_Fpx1,
                          out hv_HomMat2DRotate1);
                        ho_ContoursAffineTrans1.Dispose();
                        HOperatorSet.AffineTransContourXld(ho_RegressContoursDIR, out ho_ContoursAffineTrans1,
                          hv_HomMat2DRotate1);
                        //dev_display (ContoursAffineTrans1)
                        HOperatorSet.GetContourXld(ho_ContoursAffineTrans1, out hv_Row1, out hv_Col1);




                        //==========================================================================
                        //--> CÁLCULO DA NOTA PELA MÉDIA GERAL DAS ÁREAS
                        if ((int)(new HTuple(((hv_PdiEsqAreaBur + hv_PdiDirAreaBur)).TupleEqual(2))) != 0)
                        {
                            //- CONTADOR FRAME PROCESSADOS ANÁLISE AREA/NUMERO BURACOS:
                            hv_NumAreaBur = hv_NumAreaBur + 1;
                            //- CÁLCULO DA VARIÂNCIA LINHAS CONTORNO APÓS TRANSFORMAÇÃO AFIM:
                            HOperatorSet.TupleType(hv_Row, out hv_VarVazia);
                            if ((int)(new HTuple(hv_VarVazia.TupleEqual(15))) != 0)
                            {
                                hv_DesPadContEsq = -1;
                            }
                            else
                            {
                                HOperatorSet.TupleDeviation(hv_Row, out hv_DesPadContEsq);
                            }
                            HOperatorSet.TupleType(hv_Row1, out hv_VarVazia);
                            if ((int)(new HTuple(hv_VarVazia.TupleEqual(15))) != 0)
                            {
                                hv_DesPadContDir = -1;
                            }
                            else
                            {
                                HOperatorSet.TupleDeviation(hv_Row1, out hv_DesPadContDir);
                            }
                            //- ARMAZENA INFO BURACOS ROI ESQ DE CADA FRAME:
                            hv_VetInfBurEsq = ((((hv_VetInfBurEsq.TupleConcat(hv_Area1E))).TupleConcat(
                                hv_Area2E))).TupleConcat(hv_NBEsq);
                            HOperatorSet.CreateMatrix(hv_NumAreaBur, 3, hv_VetInfBurEsq, out hv_MtxInfBurEsq);
                            //- ARMAZENA INFO BURACOS ROI DIR DE CADA FRAME:
                            hv_VetInfBurDir = ((((hv_VetInfBurDir.TupleConcat(hv_Area1D))).TupleConcat(
                                hv_Area2D))).TupleConcat(hv_NBDir);
                            HOperatorSet.CreateMatrix(hv_NumAreaBur, 3, hv_VetInfBurDir, out hv_MtxInfBurDir);
                            //- OBTENDO AS AREAS DO FRAME DAS MATRIZES DE REGISTRO DE INFORMACAO:
                            HOperatorSet.GetValueMatrix(hv_MtxInfBurEsq, hv_NumAreaBur - 1, 0, out hv_Area1Esq);
                            HOperatorSet.GetValueMatrix(hv_MtxInfBurEsq, hv_NumAreaBur - 1, 1, out hv_Area2Esq);
                            HOperatorSet.GetValueMatrix(hv_MtxInfBurDir, hv_NumAreaBur - 1, 0, out hv_Area1Dir);
                            HOperatorSet.GetValueMatrix(hv_MtxInfBurDir, hv_NumAreaBur - 1, 1, out hv_Area2Dir);
                            HOperatorSet.GetValueMatrix(hv_MtxInfBurEsq, hv_NumAreaBur - 1, 2, out hv_NBurEsq);
                            HOperatorSet.GetValueMatrix(hv_MtxInfBurDir, hv_NumAreaBur - 1, 2, out hv_NBurDir);
                            //- CALCULO DA MÉDIA GERAL DOS FRAMES:
                            hv_MedGeral = ((((hv_Area1Esq + hv_Area2Esq) + hv_Area1Dir) + hv_Area2Dir) * 1) / 4;
                            //- CÁLCULO DA MÉDIA DOS BURACOS DOS FRAMES E DO PESO:
                            hv_MedNuBur = (hv_NBurEsq + hv_NBurDir) / 2;
                            HOperatorSet.TupleExp((-hv_MedNuBur) / 150, out hv_PesoBur);
                            hv_MedPond = hv_MedGeral * hv_PesoBur;
                            //- APLICANDO A MÉDIA NO POLINÔMIO DE REGRESSÃO (2o GRAU):
                            hv_NotaClaBur = (((0.000000004 * hv_MedPond) * hv_MedPond) - (0.0006 * hv_MedPond)) + 8.9401;
                            //- SATURADOR NOTA:
                            if ((int)(new HTuple(hv_NotaClaBur.TupleLess(0))) != 0)
                            {
                                hv_NotaClaBur = 0;
                            }
                            else if ((int)(new HTuple(hv_NotaClaBur.TupleGreater(10))) != 0)
                            {
                                hv_NotaClaBur = 10;
                            }
                        }
                        else
                        {
                            //- CODIFICAÇÃO FRAME NÃO PROCESSADO: -1
                            hv_MedGeral = -1;
                            hv_MedNuBur = -1;
                            hv_MedPond = -1;
                            hv_NotaClaBur = -1;
                        }
                        //FIM CLASSIFICADOR AREA / NUMERO BURACOS
                        //==========================================================================







                        // ------------- CRIAÇÃO DO VETOR DE NÚMEROS COMPLEXOS COM AS INFORMAÇÕES DAS LINHAS(Y) DOS PONTOS DAS BORDAS --------
                        // criação do vetor complexo com a borda direita
                        int nPontosBordaDireita = (int)(new HTuple(hv_Row1.TupleLength()));
                        double[] vetorBordaDireita = new double[nPontosBordaDireita];
                        double[] vetorEixoXBordaDireita = new double[nPontosBordaDireita];
                        for (int i = 0; i < vetorBordaDireita.Length; i++)
                        {
                            vetorBordaDireita[i] = new double();
                            vetorEixoXBordaDireita[i] = new double();
                        }
                        for (int n = 0; n < nPontosBordaDireita; n++)
                        {
                            vetorBordaDireita[n] = hv_Row1.TupleSelect(n);
                            vetorEixoXBordaDireita[n] = hv_Col1.TupleSelect(n);
                            //indexVetores++;
                        }

                        // criação do vetor complexo com a borda esquerda
                        int nPontosBordaEsquerda = (int)(new HTuple(hv_Row.TupleLength()));
                        double[] vetorBordaEsquerda = new double[nPontosBordaEsquerda];
                        double[] vetorEixoXBordaEsquerda = new double[nPontosBordaEsquerda];
                        for (int i = 0; i < vetorBordaEsquerda.Length; i++)
                        {
                            vetorBordaEsquerda[i] = new double();
                            vetorEixoXBordaEsquerda[i] = new double();
                        }
                        for (int n = 0; n < nPontosBordaEsquerda; n++)
                        {
                            vetorBordaEsquerda[n] = hv_Row.TupleSelect(n);
                            vetorEixoXBordaEsquerda[n] = hv_Col.TupleSelect(n);
                            //indexVetores++;
                        }

                        // ------------------CÁLCULO DA POTÊNCIA DE 2 MAIS PRÓXIMA DO NÚMERO DE PONTOS DE CADA BORDA ------------
                        // determina a potência de 2 mais próxima do número de amostras processadas da borda DIREITA
                        int expoente = 0;
                        while (nPontosBordaDireita > Math.Pow(2.0, (double)expoente))
                        {
                            expoente++;
                        }
                        int diferencaPotencia2 = (int)(Math.Pow(2.0, (double)expoente)) - nPontosBordaDireita;
                        //diferencaPotencia2 = 0;
                        indexVetores = nPontosBordaDireita;

                        // determina a potência de 2 mais próxima do número de amostras processadas da borda ESQUERDA
                        int expoente2 = 0;
                        while (nPontosBordaEsquerda > Math.Pow(2.0, (double)expoente2))
                        {
                            expoente2++;
                        }
                        int diferencaPotencia22 = (int)(Math.Pow(2.0, (double)expoente2)) - nPontosBordaEsquerda;
                        //diferencaPotencia2 = 0;
                        int indexVetores2 = nPontosBordaEsquerda;

                        // ------------ CÁLCULO DAS MÉDIAS DAS COMPONENTES Y DAS BORDAS ----------------
                        // cálculo da média da componente Y da borda DIREITA
                        double media = 0.0;
                        for (int n = 0; n < nPontosBordaDireita; n++)
                        {
                            media = media + vetorBordaDireita[n];
                        }
                        media = media / nPontosBordaDireita;
                        // cálculo da média da componente Y da borda ESQUERDA
                        double media2 = 0.0;
                        for (int n = 0; n < nPontosBordaEsquerda; n++)
                        {
                            media2 = media2 + vetorBordaEsquerda[n];
                        }
                        media2 = media2 / nPontosBordaEsquerda;

                        // ------ CRIAÇÃO DOS VETORES DAS BORDAS COM NÚMEROS COMPLEXOS DESCONTADAS DOS SEUS NIVEIS DC --------
                        // cálculo da média da componente Y da borda DIREITA
                        Complex[] vetorBordaDireitaComplexo = new Complex[nPontosBordaDireita + diferencaPotencia2];
                        //Complex[] y = new Complex[nPontosBordaDireita + diferencaPotencia2];
                        
                        for (int i = 0; i < vetorBordaDireitaComplexo.Length; i++)
                        {
                            vetorBordaDireitaComplexo[i] = new Complex();
                            //y[i] = new Complex();
                        }

                        
                        for (int n = 0; n < nPontosBordaDireita; n++)
                        {
                            vetorBordaDireitaComplexo[n].Real = vetorBordaDireita[n] - media;
                            vetorBordaDireitaComplexo[n].Imag = 0.0;
                            //tempo = tempo + 0.001;
                            //y[n].real = 10.0 * Math.Cos(2.0 * Math.PI * 60.0 * tempo);
                            //y[n].imag = 0.0;
                            //indexVetores++;
                        }

                        // criação do vetor complexo com a borda esquerda
                        Complex[] vetorBordaEsquerdaComplexo = new Complex[nPontosBordaEsquerda + diferencaPotencia22];
                        for (int i = 0; i < vetorBordaEsquerdaComplexo.Length; i++)
                        {
                            vetorBordaEsquerdaComplexo[i] = new Complex();
                        }
                        for (int n = 0; n < nPontosBordaEsquerda; n++)
                        {
                            vetorBordaEsquerdaComplexo[n].Real = vetorBordaEsquerda[n] - media2;
                            vetorBordaEsquerdaComplexo[n].Imag = 0.0;
                            //indexVetores2++;
                        }

                        // ---- PREENCHIMENTO DOS VETORES COMPLEXOS DAS BORDAS COM ZERO PARA GARANTIR TAMANHO MÚLTIPLO DE POTÊNCIA DE 2
                        // completa com zeros até o núm. de pontos do vetor ser uma pot. de 2 para borda direita
                        while (indexVetores < (nPontosBordaDireita + diferencaPotencia2))
                        {
                            vetorBordaDireitaComplexo[indexVetores].Real = 0.0;
                            vetorBordaDireitaComplexo[indexVetores].Imag = 0.0;
                            //tempo = tempo + 0.001;
                            //y[indexVetores].real = 10.0 * Math.Cos(2.0 * Math.PI * 60.0 * tempo) + 5.0* Math.Cos(2.0*Math.PI*150.0*tempo);
                            //y[indexVetores].imag = 0.0;
                            indexVetores++;
                            
                        } // fim "while( diferencaPontecia2 > 0 )"
                          // completa com zeros até o núm. de pontos do vetor ser uma pot. de 2 para borda esquerda
                        while (indexVetores2 < (nPontosBordaEsquerda + diferencaPotencia22))
                        {
                            vetorBordaEsquerdaComplexo[indexVetores2].Real = 0.0;
                            vetorBordaEsquerdaComplexo[indexVetores2].Imag = 0.0;
                            indexVetores2++;
                        }

                        // ---------------- EXECUTA O ALGORITMO DA FFT PARA AS BORDAS -----------------	
                        // execução do algoritmo para fft da borda direita
                        Complex[] fftVetorBordaDireita = new Complex[nPontosBordaDireita + diferencaPotencia2];
                        //Complex[] fftVetorTeste = new Complex[nPontosBordaDireita + diferencaPotencia2];
                        for (int i = 0; i < fftVetorBordaDireita.Length; i++)
                        {
                            fftVetorBordaDireita[i] = new Complex();
                        //    fftVetorTeste[i] = new Complex();
                        }
                        fftVetorBordaDireita = FFT.calculaFFT(vetorBordaDireitaComplexo);
                        //fftVetorTeste = FFT.calculaFFT(y);

                       // execução do algoritmo para fft da borda esquerda
                        Complex[] fftVetorBordaEsquerda = new Complex[nPontosBordaEsquerda + diferencaPotencia22];
                        for (int i = 0; i < fftVetorBordaEsquerda.Length; i++)
                        {
                            fftVetorBordaEsquerda[i] = new Complex();
                        }
                        fftVetorBordaEsquerda = FFT.calculaFFT(vetorBordaEsquerdaComplexo);


                        double constFFTBordaDireita = 2.0 / (nPontosBordaDireita + diferencaPotencia2);
                        double constFFTBordaEsquerda = 2.0 / (nPontosBordaEsquerda + diferencaPotencia22);
                        for (int i = 0; i < fftVetorBordaEsquerda.Length; i++)
                        {
                            fftVetorBordaEsquerda[i].Real = fftVetorBordaEsquerda[i].Real * constFFTBordaEsquerda;
                            fftVetorBordaEsquerda[i].Imag = fftVetorBordaEsquerda[i].Imag * constFFTBordaEsquerda;
                        }

                        for (int i = 0; i < fftVetorBordaDireita.Length; i++)
                        {
                            fftVetorBordaDireita[i].Real = fftVetorBordaDireita[i].Real * constFFTBordaDireita;
                            fftVetorBordaDireita[i].Imag = fftVetorBordaDireita[i].Imag * constFFTBordaDireita;
                        }


                        /*
                        // ---------------------- CLASSIFICAÇÃO DAS BORDAS -> 1a versão, câmera antiga  ------------------------------

                        // ------------------ CÁLCULO DAS ENERGIAS DA BORDA DIREITA EM ALTA E BAIXA FREQUÊNCIA  ---------------------------
                        double energiaTotalBordaDireita = 0.0;
                        int nPontosSobre2 = (int)((nPontosBordaDireita + diferencaPotencia2) / 2.0);
                        for (int n = 0; n < nPontosSobre2; n++)
                        {
                            energiaTotalBordaDireita = energiaTotalBordaDireita + Math.Pow(fftVetorBordaDireita[n].real, 2.0) + Math.Pow(fftVetorBordaDireita[n].imag, 2.0);
                        }
                        int BW_bordaDireita = (int)Math.Floor(nPontosSobre2 / 10.0);     // [pontos] - intervalo em pontos entre a baixa e a alta frequências
                                                                                         //printf("Energia total da borda direita = %lf \n",energiaTotalBordaDireita);

                        double energiaBaixaFreqDireita = 0.0;
                        for (int n = 0; n < BW_bordaDireita; n++)
                        {
                            energiaBaixaFreqDireita = energiaBaixaFreqDireita + Math.Pow(fftVetorBordaDireita[n].real, 2.0) + Math.Pow(fftVetorBordaDireita[n].imag, 2.0);
                        }
                        //printf("Energia baixa frequência da borda direita = %lf \n",energiaBaixaFreqDireita);

                        double energiaAltaFreqDireita = 0.0;
                        for (int n = BW_bordaDireita; n < nPontosSobre2; n++)
                        {
                            energiaAltaFreqDireita = energiaAltaFreqDireita + Math.Pow(fftVetorBordaDireita[n].real, 2.0) + Math.Pow(fftVetorBordaDireita[n].imag, 2.0);
                        }
                        //printf("Energia alta frequência da borda direita = %lf \n",energiaAltaFreqDireita);
                        double energiaBaixaFreqDireitaPu = energiaBaixaFreqDireita / energiaTotalBordaDireita;
                        double energiaAltaFreqDireitaPu = energiaAltaFreqDireita / energiaTotalBordaDireita;
                        double amplitudeMaximaBordaDireita = 0;
                        double freqAmpMaximaBordaDireita = 0;
                        double amplitude;
                        for (int n = 0; n < nPontosSobre2; n++)
                        {
                            amplitude = Math.Sqrt(Math.Pow(fftVetorBordaDireita[n].real, 2.0) + Math.Pow(fftVetorBordaDireita[n].imag, 2.0));
                            if (amplitude > amplitudeMaximaBordaDireita) // 
                            {
                                amplitudeMaximaBordaDireita = amplitude;
                                freqAmpMaximaBordaDireita = n;
                            }
                        }

                        // ------------------ CÁLCULO DAS ENERGIAS DA BORDA ESQUERDA EM ALTA E BAIXA FREQUÊNCIA  ---------------------------
                        double energiaTotalBordaEsquerda = 0.0;
                        int nPontosSobre22 = (int)((nPontosBordaEsquerda + diferencaPotencia22) / 2.0);
                        for (int n = 0; n < nPontosSobre22; n++)
                        {
                            energiaTotalBordaEsquerda = energiaTotalBordaEsquerda + Math.Pow(fftVetorBordaEsquerda[n].real, 2.0) + Math.Pow(fftVetorBordaEsquerda[n].imag, 2.0);
                        }
                        int BW_bordaEsquerda = (int)Math.Floor(nPontosSobre2 / 10.0);
                        //BW = 6;     // [pontos] - intervalo em pontos entre a baixa e a alta frequências
                        //printf("Energia total da borda esquerda = %lf \n",energiaTotalBordaEsquerda);

                        double energiaBaixaFreqEsquerda = 0.0;
                        for (int n = 0; n < BW_bordaEsquerda; n++)
                        {
                            energiaBaixaFreqEsquerda = energiaBaixaFreqEsquerda + Math.Pow(fftVetorBordaEsquerda[n].real, 2.0) + Math.Pow(fftVetorBordaEsquerda[n].imag, 2.0);
                        }
                        //printf("Energia baixa frequência da borda esquerda = %lf \n",energiaBaixaFreqEsquerda);
                        double energiaAltaFreqEsquerda = 0.0;
                        for (int n = BW_bordaEsquerda; n < nPontosSobre22; n++)
                        {
                            energiaAltaFreqEsquerda = energiaAltaFreqEsquerda + Math.Pow(fftVetorBordaEsquerda[n].real, 2.0) + Math.Pow(fftVetorBordaEsquerda[n].imag, 2.0);
                        }
                        //printf("Energia alta frequência da borda esquerda = %lf \n",energiaAltaFreqEsquerda);

                        double energiaBaixaFreqEsquerdaPu = energiaBaixaFreqEsquerda / energiaTotalBordaEsquerda;
                        double energiaAltaFreqEsquerdaPu = energiaAltaFreqEsquerda / energiaTotalBordaEsquerda;
                        double amplitudeMaximaBordaEsquerda = 0;
                        double freqAmpMaximaBordaEsquerda = 0;
                        //double amplitude;
                        for (int n = 0; n < nPontosSobre22; n++)
                        {
                            amplitude = Math.Sqrt(Math.Pow(fftVetorBordaEsquerda[n].real, 2.0) + Math.Pow(fftVetorBordaEsquerda[n].imag, 2.0));
                            if (amplitude > amplitudeMaximaBordaEsquerda) // 
                            {
                                amplitudeMaximaBordaEsquerda = amplitude;
                                freqAmpMaximaBordaEsquerda = n;
                            }
                        }


                        // ---------------------- CÁLCULO DA ENERGIA TOTAL DAS DUAS BORDAS DA BOBINA ------------------------------
                        double energiaTotalBaixaFreqPu = 0.5 * (energiaBaixaFreqEsquerdaPu + energiaBaixaFreqDireitaPu);
                        double energiaTotalAltaFreqPu = 0.5 * (energiaAltaFreqEsquerdaPu + energiaAltaFreqDireitaPu);

                        
                        double[] nota = new double[101];
                        double[] ybf = new double[101];
                        double[] deltaEnergiabf = new double[101];
                        double[] yaf = new double[101];
                        double[] deltaEnergiaaf = new double[101];
                        double deltaEnergiabfMin = 1.0;
                        double deltaEnergiaafMin = 1.0;
                        double notaBordabf = 10.0;
                        double notaBordaaf = 10.0;
                        double notaBordaFinal;
                        double[] coefsbf = new double[4];
                        coefsbf[0] = 0.0137;
                        coefsbf[1] = -0.2000;
                        coefsbf[2] = 0.9857;
                        coefsbf[3] = -1.0729;
                        double[] coefsbfInicio = new double[2];
                        coefsbfInicio[0] = 0.1514;
                        coefsbfInicio[1] = 0.0;
                        double[] coefsbfFinal = new double[2];
                        coefsbfFinal[0] = 0.0905;
                        coefsbfFinal[1] = 0.0953;
                        double[] coefsaf = new double[4];
                        coefsaf[0] = -0.0136;
                        coefsaf[1] = 0.1983;
                        coefsaf[2] = -0.9784;
                        coefsaf[3] = 2.0632;
                        double[] coefsafInicio = new double[2];
                        coefsafInicio[0] = -0.1514;
                        coefsafInicio[1] = 1.0;
                        double[] coefsafFinal = new double[2];
                        coefsafFinal[0] = -0.0905;
                        coefsafFinal[1] = 0.9047;
                        for (int n = 0; n <= 100; n++)
                        {
                            nota[n] = n * 0.1;
                            if (energiaTotalBaixaFreqPu < 0.45)
                            {
                                ybf[n] = coefsbfInicio[0] * nota[n] + coefsbfInicio[1];
                                yaf[n] = coefsafInicio[0] * nota[n] + coefsafInicio[1];

                            }
                            else if (energiaTotalBaixaFreqPu >= 0.45 && energiaTotalBaixaFreqPu <= 0.73)
                            {
                                ybf[n] = coefsbf[0] * Math.Pow(nota[n], 3) + coefsbf[1] * Math.Pow(nota[n], 2) + coefsbf[2] * nota[n] + coefsbf[3];
                                yaf[n] = coefsaf[0] * Math.Pow(nota[n], 3) + coefsaf[1] * Math.Pow(nota[n], 2) + coefsaf[2] * nota[n] + coefsaf[3];
                            }
                            else
                            {
                                ybf[n] = coefsbfFinal[0] * nota[n] + coefsbfFinal[1];
                                yaf[n] = coefsafFinal[0] * nota[n] + coefsafFinal[1];
                            }

                            deltaEnergiabf[n] = Math.Abs(ybf[n] - energiaTotalBaixaFreqPu);
                            deltaEnergiaaf[n] = Math.Abs(yaf[n] - energiaTotalAltaFreqPu);

                            if (deltaEnergiabf[n] < deltaEnergiabfMin)
                            {
                                deltaEnergiabfMin = deltaEnergiabf[n];
                                notaBordabf = n / 10.0;
                            }

                            if (deltaEnergiaaf[n] < deltaEnergiaafMin)
                            {
                                deltaEnergiaafMin = deltaEnergiaaf[n];
                                notaBordaaf = n / 10.0;
                            }
                        }

                        notaBordaFinal = 0.5 * (notaBordabf + notaBordaaf);

                        if (notaBordaFinal > 8.0)
                        {
                            double energiaCompMaxBordaDir = amplitudeMaximaBordaDireita * amplitudeMaximaBordaDireita;
                            double energiaCompMaxBordaEsq = amplitudeMaximaBordaEsquerda * amplitudeMaximaBordaEsquerda;
                            //double energiaBordaDirMenosCompMax = energiaTotalBordaDireita - energiaCompMaxBordaDir;
                            //double energiaBordaEsqMenosCompMax = energiaTotalBordaEsquerda - energiaCompMaxBordaEsq;

                            if ((energiaCompMaxBordaDir / energiaTotalBordaDireita) >= 0.5 || (energiaCompMaxBordaEsq / energiaTotalBordaEsquerda) >= 0.5)
                            {
                                notaBordaFinal = 4.0;
                            }
                        }

                        ---------------- FIM DA 1A VERSÃO DO CLASSIFICADOR BASEADO NA CÂMERA ANTIGA -----------------------
                        */


                        // --------------------------------------------------------------------------------------------------
                        // --------------- INÍCIO DA 2A VERSÃO DO CLASSIFICADOR BASEADO NA CÂMERA NOVA ----------------------

                        // ------------------ CÁLCULO DA ENERGIA DA BORDA DIREITA   ---------------------------
                        double energiaTotalBordaDireita = 0.0;
                        double energiaTotalBordaEsquerda = 0.0;
                        double energiaMedia = 0.0;
                        double notaBordaFinal;
                        
                        for (int n = 0; n < 40; n++)
                        {
                            energiaTotalBordaDireita = energiaTotalBordaDireita + Math.Pow(fftVetorBordaDireita[n].Real, 2.0) + Math.Pow(fftVetorBordaDireita[n].Imag, 2.0) ;
                            energiaTotalBordaEsquerda = energiaTotalBordaEsquerda + Math.Pow(fftVetorBordaEsquerda[n].Real, 2.0) + Math.Pow(fftVetorBordaEsquerda[n].Imag, 2.0) ;
                        }

                        if (energiaTotalBordaDireita >= energiaTotalBordaEsquerda)
                            energiaMedia = (2*energiaTotalBordaDireita + energiaTotalBordaEsquerda) / 3;
                        else energiaMedia = (2*energiaTotalBordaEsquerda + energiaTotalBordaDireita) / 3;

                        notaBordaFinal = -2.6406e-09*Math.Pow(energiaMedia,3.0) + 1.023e-05*Math.Pow(energiaMedia, 2.0) - 0.016104*energiaMedia + 11.086;
                        //-4.168e-09*Math.Pow(energiaMedia,3.0) + 1.464e-05*Math.Pow(energiaMedia,2.0) - 0.01805*energiaMedia + 11.76;

                        // --------------------------------------------------------------------------------------------------
                        // ------------------ FIM DA 2A VERSÃO DO CLASSIFICADOR BASEADO NA CÂMERA NOVA ----------------------

                        // ------------------- gravação do arquivo com as notas das bordas -----------------------------------
                        double notaPelosBuracos = hv_NotaClaBur;
                        if (notaBordaFinal < 0)
                            notaBordaFinal = 0.0;
                        if (notaBordaFinal > 10.0)
                            notaBordaFinal = 10.0;
                        if (notaPelosBuracos < 0)
                            notaPelosBuracos = 0.0;
                        if (notaPelosBuracos > 10.0)
                            notaPelosBuracos = 10.0;
                        double notaBordaFinalMedia = 0.5 * (notaBordaFinal + notaPelosBuracos);
                        vetorNotasPeloEspectro[numeroDeNotas] = notaBordaFinal;
                        vetorNotasPelosBuracos[numeroDeNotas] = notaPelosBuracos;
                        vetorNotasMedias[numeroDeNotas] = notaBordaFinalMedia;
                        data = CurrentTime.Date.ToString("dd_MM_yyyy");
                        vetorDatas[numeroDeNotas] = data;
                        horario = DateTime.Now.ToString("HH_mm_ss_fff tt");// DateTime.Now.TimeOfDay
                        vetorHorarios[numeroDeNotas] = horario;
                        numeroDeNotas = numeroDeNotas + 1;
                        //arquivoNotas.WriteLine(data + " " + horario + " " + notaBordaFinal.ToString("N", nfi));// (FFTVetorBorda[i].real.ToString("N", nfi) + " " + FFTVetorBorda[i].imag.ToString("N", nfi));
                        //arquivoNotas.WriteLine(data + "  " + horario + "  " + notaBordaFinal.ToString("N", nfi) + "  " + notaPelosBuracos.ToString("N", nfi) + "  " + notaBordaFinalMedia.ToString("N", nfi));// (FFTVetorBorda[i].real.ToString("N", nfi) + " " + FFTVetorBorda[i].imag.ToString("N", nfi));


                        // -------------- gravação dos arquivos de imagem para cada frame amostrado --------------------------
                        //hv_nomeArquivoVideoSaida = "C:\\Users\\Administrador\\Documents\\classificadorDeBobinas\\FormacaoVideos\\CodigoEmC#\\HDevelopTemplateWPF\\HDevelopTemplateWPF\\vs2008\\imagemParaVideo";
                        //HOperatorSet.TupleString(hv_ImageNum, "04d", out hv_ImageNumString);
                        //HOperatorSet.TupleAdd(hv_nomeArquivoVideoSaida, hv_ImageNumString, out hv_nomeArquivoVideoSaida);
                        //HOperatorSet.TupleAdd(hv_nomeArquivoVideoSaida, ".png", out hv_nomeArquivoVideoSaida);
                        //HOperatorSet.WriteImage(ho_Image, "png fastest", 255, hv_nomeArquivoVideoSaida);


                        // arquivoResultadoFFTTeste = File.CreateText("C:\\Users\\NOTEBOOK\\Documents\\pesquisas\\gerdau\\FORMACAODEESPIRAS\\FormacaoVideos\\CodigoEmC#\\HDevelopTemplateWPF\\HDevelopTemplateWPF\\vs2008\\fftResultadoTeste");
                        // ------------- gravação dos arquivos com os pontos das bordas e do fft ----------------------------
                        //if (hv_ImageNum == 30)
                        //{
                        /*    for (int i = 0; i < fftVetorBordaDireita.Length; i++)
                            {
                                arquivoResultadoFFTBordaDireita.WriteLine(fftVetorBordaDireita[i].real.ToString("N", nfi) + " " + fftVetorBordaDireita[i].imag.ToString("N", nfi));
                                //arquivoResultadoFFTTeste.WriteLine(fftVetorTeste[i].real.ToString("N", nfi) + " " + fftVetorTeste[i].imag.ToString("N", nfi));
                            }
                            for (int i = 0; i < vetorBordaDireita.Length; i++)
                            //for (int i = 0; i < fftVetorBordaDireita.Length; i++)
                            {
                                arquivoPontosBordaDireita.WriteLine(vetorEixoXBordaDireita[i].ToString("N", nfi) + " " + vetorBordaDireita[i].ToString("N", nfi));
                                //arquivoPontosBordaDireita.WriteLine(y[i].real.ToString("N", nfi) + " " + y[i].imag.ToString("N", nfi));
                            }

                            arquivoResultadoFFTBordaDireita.Close();
                            arquivoPontosBordaDireita.Close();
                            //arquivoResultadoFFTTeste.Close();

                            for (int i = 0; i < fftVetorBordaEsquerda.Length; i++)
                            {
                                arquivoResultadoFFTBordaEsquerda.WriteLine(fftVetorBordaEsquerda[i].real.ToString("N", nfi) + " " + fftVetorBordaEsquerda[i].imag.ToString("N", nfi));
                            }
                            for (int i = 0; i < vetorBordaEsquerda.Length; i++)
                            {
                                arquivoPontosBordaEsquerda.WriteLine(vetorEixoXBordaEsquerda[i].ToString("N", nfi) + " " + vetorBordaEsquerda[i].ToString("N", nfi));
                            }
                            arquivoResultadoFFTBordaEsquerda.Close();
                            arquivoPontosBordaEsquerda.Close();
                            */

                        //}
                    }
                }
                //notaBordabf = notaBordabf;
            }

            /*if (hv_ImageNum >= 201)
            { 
                arquivoNotas.Close();
                double notaBordaFinal = 0.0;
            }*/

            if (token.IsCancellationRequested)
            {
                HOperatorSet.CloseFramegrabber(hv_AcqHandle);
                ho_Image.Dispose();
                arquivoNotas.Close();
                break;
            }
        }

        //fecha o arquivo txt com as notas das bordas
        arquivoNotas.Close();
        //executa ffmpeg para montar o arquivo de video com as imagens gravadas em arquivos png
        //HOperatorSet.SystemCall("ffmpeg -framerate 33 -pattern_type sequence -start_number 1 -i \"imagemParaVideo%04d.png\" -vcodec mpeg4 teste9.avi");
        //apaga os arquivos de imagens dos frames amostrados do formador
        //Process.Start()
        //Process.Start(@"C:\Users\Administrador\Documents\classificadorDeBobinas\FormacaoVideos\CodigoEmC#\HDevelopTemplateWPF\HDevelopTemplateWPF\vs2008\del imagemParaVideo0001.png");
        //Console. .WriteLine("del imagemParaVideo0001.png");// "Count: {0}", processes.Length);
        //HOperatorSet.SystemCall("del imagemParaVideo0001.png");
    
        /*
        ProcessStartInfo startInfo = new ProcessStartInfo();
        // Configure the process using the StartInfo properties.
        startInfo.CreateNoWindow = false;
        startInfo.UseShellExecute = false;
        startInfo.FileName = "ffmpeg.exe";
        startInfo.Arguments = "-framerate 33 -pattern_type sequence -start_number 1 -i \"imagemParaVideo%04d\" -vcodec mpeg4 C:\\Users\\Administrador\\Documents\\classificadorDeBobinas\\FormacaoVideos\\CodigoEmC#\\HDevelopTemplateWPF\\HDevelopTemplateWPF\\teste11.avi";
        startInfo.WindowStyle = ProcessWindowStyle.Hidden;
        using (Process exeProcess = Process.Start(startInfo))
        { 
            exeProcess.WaitForExit();// Waits here for the process to exit.
        }
    
        //startInfo.Arguments = " C:\\Users\\Administrador\\Documents\\classificadorDeBobinas\\FormacaoVideos\\CodigoEmC#\\HDevelopTemplateWPF\\HDevelopTemplateWPF\\vs2008\\del imagemParaVideo0001.png";
        */
    
        //
        //!Retirei essa linha
        //HOperatorSet.CloseFramegrabber(hv_AcqHandle);

        ho_Image.Dispose();
        ho_RectangleEsq.Dispose();
        ho_REsqXLD.Dispose();
        ho_RectangleDir.Dispose();
        ho_RDirXLD.Dispose();
        ho_ImageReducedEsq.Dispose();
        ho_GrayImageEsq.Dispose();
        ho_ImageEmphasizeEsq.Dispose();
        ho_RegionEsq.Dispose();
        ho_ContoursEsq.Dispose();
        ho_FullLeftContour.Dispose();
        ho_ContornoEsq.Dispose();
        ho_ContornoEsq2.Dispose();
        ho_SmoothedContoursESQ.Dispose();
        ho_RegressContoursESQ.Dispose();
        ho_Line.Dispose();
        ho_ContoursAffineTrans.Dispose();
        ho_ImageReducedDir.Dispose();
        ho_GrayImageDir.Dispose();
        ho_ImageEmphasizeDir.Dispose();
        ho_RegionDir.Dispose();
        ho_ContoursDir.Dispose();
        ho_FullRightContour.Dispose();
        ho_ContornoDir.Dispose();
        ho_SmoothedContoursDIR.Dispose();
        ho_RegressContoursDIR.Dispose();
        ho_ContoursAffineTrans1.Dispose();
        // ========================================================
        // Funções do Classificador Area/Número Buracos:
        ho_ContornoEsqAux.Dispose();
        ho_ContornoEsqRed.Dispose();
        ho_ContRegBurEsq.Dispose();
        ho_DomRegBurEsq.Dispose();
        ho_RegBurEsq.Dispose();
        ho_BurEsq.Dispose();
        ho_BurEsqCon.Dispose();
        ho_FullRightContour.Dispose();
        ho_ContornoDir.Dispose();
        ho_ContornoDirAux.Dispose();
        ho_ContornoDirRed.Dispose();
        ho_ContRegBurDir.Dispose();
        ho_DomRegBurDir.Dispose();
        ho_RegBurDir.Dispose();
        ho_BurDir.Dispose();
        ho_BurDirCon.Dispose();
        // ========================================================

    }

    public void InitHalcon()
    {
        // Default settings used in HDevelop 
        HOperatorSet.SetSystem("width", 512);
        HOperatorSet.SetSystem("height", 512);
    }

    public void RunHalcon(HTuple Window, HTuple hv_acqHandle, CancellationToken token, string folderPath)
    {
        this.token = token;
        hv_ExpDefaultWinHandle = Window;
        this.folderPath = folderPath;
        action(hv_acqHandle);
        
    }

    /*
    private void makeVideo()
    { 
        string outputFile = "FadeBetweenImages.wmv";
        using (ITimeline timeline = new DefaultTimeline())
        {
            IGroup group = timeline.AddVideoGroup(32, 160, 100);
            ITrack videoTrack = group.AddTrack();
            IClip clip1 = videoTrack.AddImage("image1.jpg", 0, 2); // play first image for a little while
            IClip clip2 = videoTrack.AddImage("image2.jpg", 0, 2); // and the next
            IClip clip3 = videoTrack.AddImage("image3.jpg", 0, 2); // and finally the last
            IClip clip4 = videoTrack.AddImage("image4.jpg", 0, 2); // and finally the last
        }

        double halfDuration = 0.5;

        // fade out and back in
        group.AddTransition(clip2.Offset - halfDuration, halfDuration, StandardTransitions.CreateFade(), true);
        group.AddTransition(clip2.Offset, halfDuration, StandardTransitions.CreateFade(), false);

        // again
        group.AddTransition(clip3.Offset - halfDuration, halfDuration, StandardTransitions.CreateFade(), true);
        group.AddTransition(clip3.Offset, halfDuration, StandardTransitions.CreateFade(), false);

        // and again
        group.AddTransition(clip4.Offset - halfDuration, halfDuration, StandardTransitions.CreateFade(), true);
        group.AddTransition(clip4.Offset, halfDuration, StandardTransitions.CreateFade(), false);

        // add some audio
        ITrack audioTrack = timeline.AddAudioGroup().AddTrack();

        IClip audio = audioTrack.AddAudio("testinput.wav", 0, videoTrack.Duration);

        // create an audio envelope effect, this will:
        // fade the audio from 0% to 100% in 1 second.
        // play at full volume until 1 second before the end of the track
        // fade back out to 0% volume
        audioTrack.AddEffect(0, audio.Duration,StandardEffects.CreateAudioEnvelope(1.0, 1.0, 1.0, audio.Duration));

        // render our slideshow out to a windows media file
        using (IRenderer renderer = new WindowsMediaRenderer(timeline, outputFile, WindowsMediaProfiles.HighQualityVideo))
        {
            renderer.Render();
        }
    }
    */
    /*
    private void makeAvi(string imageInputfolderName, string outVideoFileName, float fps = 12.0f, string imgSearchPattern = "*.png")
    {   // reads all images in folder 
        VideoWriter w = new VideoWriter(outVideoFileName, new Accord.Extensions.Size(480, 640), fps, true);
        Accord.Extensions.Imaging.ImageDirectoryReader ir = new ImageDirectoryReader(imageInputfolderName, imgSearchPattern);
        while (ir.Position < ir.Length)
        {
            IImage i = ir.Read();
            w.Write(i);
        }
        w.Close();
    }
    */
}